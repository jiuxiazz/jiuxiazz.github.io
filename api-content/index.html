{"posts":[{"title":"MySQL","content":"什么是数据库 数据库: 将大量数保存起来,通过计算机加工而成的可以高效访问的数据集合称为数据库(DateBase,简称DB) 用来管理数据库的计算机系统称为数据库管理系统(DateBase Management System ,简称DBMS) 从事管理和维护数据库管理系统(DBMS)的相关工作人员称为数据库管理员(DateBase Administrator,简称DBA) 数据库的分类: 层次式数据库 网络式数据库 关系型数据库 如今,前两种基本消失,最常用的数据库模型主要是两种:即关系型数据库和非关系型数据库. 关系型数据库 关系型数据库模型是把复杂的数据结构归结为简单的二元关系(即二维表格式).在关系数据库中,对数据的操作几乎全部建立在一个或多个关系表格上,通过对这些关联表分类.合并.连接或选取等运算来实现数据的管理.它是由多个表组成的,表与表之间是有联系的: 表的结构为: 关系就是数据能够对应的匹配，在关系型数据库中正式名称叫联结，对应的英文名叫join。 MySQL SQL SQL全称为（Structured Query Language）即结构化查询语言，使用SQL语言来对数据库进行操作，数据库就像是碗，里面的数据是土豆泥，吃土豆泥时需要一个勺子，SQL就是起到勺子的功能，用于从数据库中有结构的查询。 NoSQL NoSQL，泛指非关系型的数据库（non-relational 或 Not Only SQL),区别于关系型数据库，他们不保证关系数据的ACID特征。 SQL和NoSQL的vs SQL在应对超大规模和高并发的SNS类型的web2.0纯动态网站存在很多难以克服的问题,但是NoSQL就可以解决大规模数据集合多重数据种类带来的挑战,尤其是大数据应用的难题. 主流数据库 关系型数据库各元素 表由表名.行,列,列名构成 表名是表的名称 列名表示列的名字,列名不可以重复 表格实质上是一个二维数组,行和列都是从0开始数的 数据库和表 一个数据库中可以存在多个表,表与表之间可以存在联系也可以不存在. 表名 表名就是表格名,在MySQL中一般使用英文小写字母来约定表名. 字段 在数据库中,每一列都是一个字母,第一行是字段名,下面都是字段的值,读取时,从第二行开始读取,对应的数组下标时0,其中字段必须时唯一的,即不能出现同名的字段.字段用来约定行的值或者和其他的表产生联系.它的值可以为NULL. 允许为NULL的情况需要尽量避免,即保证所以的数据都有值. 主键 每一张数据库表都可以有一个主键,主键最大的作用就是用来标识数据,每个数据库表的主键都是不同的,主键可以没有,但是会被限制各种权限,所以规范表结构设计中,必须要有主键. 主键特点: 主键是一个特殊字段 表格可以没有主键,但是最多只能拥有一个主键 主键的值不能为NULL,必须有对应的值 主键的值必须是绝对唯一的,即不能出现两个相同的主键值. 一般使用主键和其他表进行关联 SQL常用的数据类型 VARCHAR:可变的字符串,可以类比于java中的String类型 INT:整型,和Java中的int类型一致 DOUBLE:浮点型,和java中的double类型一致,一般不加长度限制 DATETIME:时间类型,长度为0,格式为YYYY-MM-DD HH:MM:SS. BIGINT:长整型，和java中的long类型一致. NULL表示这个字段的值没有填写，可以对值为NULL的字段重新赋值. 数据 数据库表中的一行称为一条数据，存储形式为key-value键-值对，数据库中的一条数据就像是value，而主键就像是它的key，通过主键来快速查找数据，也可以通过其他字段来操作数据。 CRUD CRUD即为，创建（Create）、读取（Read）、更新（Update）、删除（Delete）；其行为通常是为了针对某个特定资源所做出的举动。其在SQL中对应的专业术语为： 安装MySQL 在官网下载mysql，然后在下载好的目录下创建一个my.ini的文件，并将下面的内容复制到文件内： 要注意文件内路径要改为自己的路径。 然后以管理员 的身份打开cmd并切换到bin目录下，然后执行 mysqld --initialize --console 此时给与的回复内容中包含了初始密码（要记住） 然后启动MySQL服务并登录MySQL（可参考下一章的SQL语句） 先进行修改密码 ALTER USER 'root'@'localhost' IDENTIFIED BY '111111'; 该语句中最后的111111即为改后的密码（此处自行设置） 环境配置: 在系统变量中创建一个新的变量，变量名为MYSQL_HOME，变量值为MySQL所在目录，最后在系统变量Path中添加%MYSQL_HOME%\\bin. docker安装MySQL 数据库表设计的范式要求 1NF： 字段是最小的的单元不可再分 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键 3NF：满足2NF,非主键外的所有字段必须互不依赖 4NF：满足3NF,消除表中的多值依赖 在互联网公司使用MySQL设计表结构时，需要遵从以下的规范： 表必须要有主键 一个字段只表示一个含义 总是包含两个日期字段：gmt_created（创建日期），gmt_modified(修改日期)，且这两个字段不应该包含有额外的业务逻辑。 MySQL中，gmt_created、gmt_modified使用DATETIME类型。 禁止使用复杂数据类型（数组，自定义类型等） 禁止使用物理外键，使用逻辑外键 禁止物理删除，使用逻辑删除is_deleted 逻辑外键：例如表B记录表A的id，我们只需在表B中添加一列：a_id就可以了，然后通过程序去控制外键关系，这就是逻辑外键。 逻辑删除：又称软删除，假删除，是一种数据库操作，使用标记将数据标为不可用，而不是从数据库删除数据本身。使用适当的方法可以恢复被删除的数据。 SQL命令 启动：net start mysql 或者 mysqld --console 关闭：net stop mysql 或者 mysqladmin -uroot shudown 登录：mysql -uroot 创建库：CREATE DATABASE 库名 登出：\\quit 退出：exit 创建表:CREATE DATABASE 表名 创建表格（详细）： 删除表格：drop table table_name; 或 DROP TABLE IF EXISTS table_name (table_name即要删除的表明，IF EXISTS意思为如果存在，删除表格的操作是不可逆的） 执行sql语句：mysql -h 192.168.0.1 -uroot -Dyoukedadb -e 'SQLy语句'（192.168.0.1表示IP，-uroot表示使用root用户，-Dyoukedadb表示操作youkedadb这个库，-e表示执行后面单引号内的SQL语句） 查看表格结构：desc ` 表名`; 插入语句： 插入语句（详细）： 备份数据:mysqldump -h 192.168.0.1 -uroot youkedadb&gt;youkedadb.sql 数据恢复:mysql -h 192.168.0.1 -uroot -Dyoukedadb &lt; youkedadb.sql 该命令需要先cd到含youkedadb.sql的文件下,然后执行. &lt;youkedadb.sql表示运行当前项目目录下的youkedadb.sql文件 &gt;youkedadb.sql表示导出该数据库中的数据至youkedadb.sql文件 查询语句： 优化查询： 嵌套查询： 集合查询： 基于派生表的查询： 更新语句： 删除语句： 关联查询： 视图： 数据库安全： 扩展： 内连接获取如下内容： 外连接的扩展： 上课知识 主码与候选码 任何关系都有主码，且唯一 任何关系必有候选码，候选码不一定唯一 当关系只有一个候选码时，该关系的码就是候选码，也是其主码 若关系中的某一属性组的值能唯一地标识一个元组，而其子集不能，则称该属性组为候选码。 若一个关系中有多个候选码，则选定一个为主码，一个关系可以没有主码，但有主码效率更高。 主码不一定是只有一个属性，主码可以由一个或者多个属性组成。主码是候选码之一。 关系的性质 列同质----列值来自同一个域 列不同名----不同的属性要用不同的属性名 列无序----列的顺序可以交换 行不全同----两个元组不能完全相同，即任意元组在关系中都是唯一的 行无序----行的顺序可以交换 原子属性----每一分量必须是不可分的数据项。（最基础的一条） 关系模式 关系模式一般使用二元关系模式，即关系名（属性） 关系数据库 关系数据库是指在一个给定的应用领域中，所以实体及实体之间联系的关系的集合。 关系数据库有型和值之分 型：关系数据库模式，它是相对固定，包含域的定义以及域上定义的若干关系模式。 值：关系模式在某一时刻对应的关系的集合，是数据库的内容，它是随时间而变化的（通常被称为关系数据库） 外码 外码：F是关系R的属性，但不是R的码，是关系S的码，则F是R的外码 如果一个关系中的一个属性（该属性不是候选码）是另一个关系中的主码，则称这个属性为外码。 作用： 保持数据一致性，完整性，主要目的是控制存储在外键表中的数据。 使两张表形成关联，外键只能引用外表中的列的值或使用空值。 基本关系R-参照关系 基本关系S-被参照关系或目标关系 外码F是两个关系共同具有的属性 外码与主码的对应提供了一种实现两个关系联系的方法。 外码F的值或取空值或取主码值 空值（F的每个属性值均为空值） 等于被参照关系S中某个元组的主码值。 外码取空值的时机： 关系的外码不是该关系主码的属性时，外码可以取空值 关系模型的三类完整性约束 实体完整性 规定主码的取值 参照完整性 规定外码的取值 用户定义的完整性 规定其他属性的取值 运算符 数据库完整性检查和违约处理 违约处理有三个： 拒绝操作：NO ACTION 级联操作：CASCADE 设置空值：当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所以造成不一致的元组的对应属性设置为空值。 拒绝和级联操作都是用在外码设置时定义的。如： ","link":"https://jiuxiazz.github.io/post/mysql/"},{"title":"GO","content":"一、 Go语言概述 1. 工程管理 GOPATH go语言的项目，需要有特定的目录结构进行管理，不能随便写，一个标准的go工程需要有三个目录：使用一个名为GOPATH的环境变量来指定： src： 放自己的源代码 bin： 编译之后的程序，使用标准命令go install之后存放的位置 pkg： 缓存包 GOROOT 存放Go的sdk 2. HelloWorld概览 3. go语言特点 没有头文件概念 强类型的语言，编译型语言 一个go语言的应用程序，在运行的时候不需要依赖外部库的 把执行时需要的所以库都打包到程序中 go程序比较大 如果import的包在程序中没有使用，那么 程序不允许编译 go语言不区分平台，需要配置两个环境变量来控制： GOOS：设置运行的平台 mac： GOOS=darwin linux： GOOS=linux windows： GOOS=windows GOARCH：目标平台的体系构架 386： GOARCH=386 amd64： GOARCH=amd64 arm： GOARCH=arm 在Terminal中使用GOOS（或GOARCH）=。。。来设置GOOS（GOARCH） 4. Terminal配置成shell 打开goland 按照File-&gt;Settings-&gt;Tools-&gt;Terminal打开 将Shell path内容更换为git bash的exe文件即可 5. go命令 编译.go文件，-o指定生成文件的名字 go build -o exe文件名（生成） go文件（带后缀） go build *.go 直接运行.go文件 go run go文件(带后缀) go run *.go 安装程序 使用go install，可以将应用程序安装到GOBIN下面：$GOPATH/bin 使用前需要在环境变量中设置GOBIN目录 查看当前go的环境变量 go env 更改环境变量，需要重启终端才会生效 二、 基础语法 1. 变量定义 基础数据类型： 2. 自增语法 go语言允许：i++， i-- 不允许：++i，i-- 且自增语法必须独占一行 3. 指针 4.不支持的语法汇总 自增--i,++i不支持 不支持地址加减 不支持三目运算符 只有false才能代码逻辑假,数字0和nil不能 5.字符串 6.数组(切片（不定长数组）、slice) 定长数组： 不定长数组： 切片： 7.字典 8. 函数 内存逃逸 9. import 10. switch 11.标签Label 12.枚举 13.结构体 14. init函数 c语言没有init函数,C语言一般需要自己去写init,然后在构造函数中调用 Go语言子带init函数,每一个包都可以包含一个或多个init函数 这个init会在包被引用的时候进行自动调用 15. defer(延迟) 延迟,关键字,可以用于修饰语句,函数,确保这条语句可以在当前栈退出的时候执行 go语言可以使用defer来解决这个问题 实例： 二、类相关操作 go语言支持类的操作，但是没有class关键字，是使用struct来实现 1. 封装 2.继承 3.接口 4.多态 定义一个接口，里面设计好需要的接口，可以有多个 任何实现了这个接口的类型，都可以赋值给这个接口，从而实现多态 多个类之间不需要有继承关系 如果interface中定义了多个接口，那么实际类必须全部实现接口函数，才可以赋值 三、并发相关 1.基础 并发：电脑同时听歌，看小说，看电影 。cpu根据时间片进行划分、交替执行这三个程序。 并行：多个cpu同时执行 c语言里实现并发过程使用的是多线程 go语言里面不是线程，而是go程---goroutine，go程是go语言原生支持的 每一个go程占用的系统资源远远小于线程，一个go程大约需要4k-5k的内存资源 一个程序可以启动大量的go程： 线程--几十个 go程可以启动成百上千个--对于高并发，性能良好 只需要在目标函数前加上go关键字即可 2.提前退出go程 3.多go程协同(管道) 如果读写不对等时 如果阻塞在主go程,会导致程序崩溃 如果阻塞在子go程,会导致内存泄漏 对于不对等情况的解决方案 总结： 当管道写满了，写阻塞 当缓冲区读完了，读阻塞 如果管道没有使用make分配空间，管道默认是nil 从nil的管道中读取数据、写入数据、都会阻塞 从一个已经close的管道读取数据时，会返回零值（不会崩溃） 向一个已经close的管道写数据时，会崩溃 关闭一个已经 close的管道，那么程序会崩溃 close的动作，一定要在写管道的地方执行 读和写的次数，一定要对等，否则： 在多个go程中：资源泄露 在主go程中，程序崩溃 4.判断管道是否已经关闭 需要知道一个管道的状态，如果已经关闭了，读不怕，会返回零，如果再写入的话，有崩溃的风险 map ==&gt; v, ok :=map channel ==&gt; v, ok := &lt;- numChan 5.单向通道 numChan := make(chan int, 10) ==&gt;双向通道，既可以读，也可以写 单向通道：为了明确语义，一般用于函数参数 单向读通道 var numChanReadOnly &lt;- chan int 单向写通道 var numChanWriteOnly chan &lt;- int 6.select 当程序中有多个channel协同工作，chan1，chan2，某一个时刻，chan1或chan2触发了，程序要做出相应的处理 使用select来监听多个通道，当管道被触发时（写入数据、读取数据、关闭管道） select语法与switch case很像，但是所有的分支条件都必须是管道io 四、网络分层 五、Socket 1.server 接收一次数据：(server) client: 处理多连接(可以接收多次数据）： 六、HTTP 1. 概述 编写web语言： java php python go --&gt;beego，gin两个主流的web框架 https协议：使用浏览器访问的时候发送的就是http请求 http是应用层的协议，底层还是依赖传输层：tcp，网络层（ip） 无状态的，每一次请求都是独立的，下次请求需要重新建立连接 https： http是标准协议--》明文传输，不安全 https不是标准协议--》https=http+ssl（非对称加密，数字证书） 2. http请求报文格式 一个请求可以分为4部分： 请求行 格式：请求方法+URL+协议版本号 实例：POST + /chapter17/user.html +HTTP/1.1 请求方法： GET：获取数据 POST：上传数据 PUT：修改数据 DELETE：用于删除数据 请求头 格式：key：value 可以有多个键值对 常见重要头： Accept：接收数据的格式 User-Agent：描述用户浏览器的信息 Connection：Keep-Alive（长链接），Close（短连接） Accept-Encoding：描述可以接受的编码 Cookie：由服务器设置的key：value数据，客户端下次请求的时候可以携带过来 Content-Type：application-form（表示上传的数据是表单格式），application/json（表示上传的数据是json格式） 空行 告诉服务器，请求头结束了，用于分隔 请求包体 一般在POST方法时，会配置提供BODY 在GET的时候也可以提供BODY，但是会让人混淆 上传两种数据格式： 表单 json数据 3. http响应消息格式 http响应格式： 状态行 协议格式：协议版本号+状态码+状态描述 实例：HTTP/1.1 + 200 +OK 常用的状态码： 1xx --&gt;客户端可以继续发送请求 2xx --&gt;正常访问 3xx --&gt;重定向 4xx 401 --&gt;未授权 not authorized 404 --&gt; NOT found 5xx 501--&gt;internal Error (服务器内部错误) 响应头 Content-Type Server Data 空行 用于分隔 响应包体 通常是返回JSON 4. http-client 5. http-server 6.json json编解码 在网络中传输的时候，把结构体，编码成json字符串，传输--》结构体--》字符串--》编码 接收字符串，需要将字符串转换成结构体，然后操作--》字符串--》结构体--》解密 json结构体标签 ","link":"https://jiuxiazz.github.io/post/go/"},{"title":"并发开发","content":"Lambda表达式 基本结构是：f -&gt; { } 其中：f是参数变量，-&gt;是语法符号，{}是语句块。参数类型是系统根据上下文自动识别的。 在功能上相当于一个匿名方法： forEach()方法是java集合和流的循环方法。 这里的forEach只是因为同名且都是迭代用的，所以不要混淆了，实际上两者的方法是无关的。仅仅为了遍历，两者是相同的。 因为Lambda表达式中参数变量的类型特性，所以使用时要配合上下文、跟其他方法配合使用，而不是一个独立的语句。 有类型参数 在表达式参数为多个时，需要用（）进行包裹，之间用逗号隔开；如果没有参数，需要用（）包裹。 无类型参数 与有类型不同，无类型参数即使只有一个参数也必须使用小括号（）包裹。 引用外部变量 在Lambda表达式中，要遵循两个规范： 引用的局部变量不允许被修改，即使是写在表达式后面也不行。（被引用的局部变量即使不声明为final，也具备final的特性：变量值初始化后不允许被修改） 参数不能与局部变量同名。 双冒号::操作符 语法含义： 例：System.out::println中，System.out就是类名，::是语法符号，println是方法名。 类似于**C++**中双冒号的使用 用法一：静态方法调用： 类名+::+方法名 用法二：非静态方法调用： 因为不再标识为static,所以需要 实例对象来调用。 实例对象+::+方法名 用法三：多参数 例： 用法四：父类方法 ::语法也可以用super关键字调用父类的非静态方法。 流（Stream API） 创建流 **Stream&lt;String&gt; stream = Stream.of()**括号内可以是字符串，数组等。 **Stream&lt;String&gt; stream = fruits.stream()**这里的fruits是集合名。 迭代流 stream.forEach(System.out::println); 流数据过滤 流的原理 管道模型：每个节点是依次执行的，下一个节点必须等待上一个节点执行完毕。这种执行方式，通常叫做串行。 map()方法 该方法通常称作映射，其作用就是用新的元素替换掉流中原来相同位置的元素。 优点是：映射后的对象类型，可以与流中原始的对象类型不一致。 映射不会改变原有的数据。 sorted()方法 排序方法 limit()方法 该方法作业是返回流的前n个元素，前提是n不能为负，其只能从流开头开始 并行数据 流并行 对于一个多数求和的算术，可以采用**reduce（）**的方法，该方法的作用是合并所有的元素，终止计算出一个结果。（和forEach（）方法一样，都是流的终点）。 reduce方法的返回值是一个比较复杂的对象，需要调用**get（）**方法返回最终的整数值。 get（）方法返回值的类型，也是系统自动根据流中元素类型推定的。 reduce()方法的参数意义： a在第一次执行计算语句时，指代流的第一个元素；然后充当缓存作用以存放本次计算结果。此后执行计算语句时，a的值就是上一次的计算结果并继续充当缓存存放本次计算结果。 b参数第一次执行计算语句时指代流的第二个元素。此后依次指代流的每一个元素。 a，b两个参数的作用是由位置决定的，变量名是任意的 以1~10累加为例，过程图示为: reduce方法参数也可以是对象，但是在使用时按照第一种单参数形式使用，可能会出现流的首对象出现bug，破坏其正确性，因为第一个对象被用于充当缓存角色了。 解决方法： 使用reduce的另外一个参数来解决，可以自己new一个对象充当缓存角色，而不是使用流中的原始对象。 reduce方法的参数变为两个： 第一个参数，是作为缓存角色的对象 第二个参数，是Lambda表达式，完成计算，格式是一样的。 那么a变量不再指代流中的第一个元素了，专门指代缓存角色的对象，即方法第一个参数对象。 b变量依次指代流中的每个元素，包括第一个元素。 图示： 该使用方式不需要再调用一次get（）方法。 流收集 除了**forEach()和reduce()**之外，还有一个流的终点：收集 在实际工作中，整体功能如果比较复杂的话，使用流对集合进行计算后，可能并不想输出和合并，而是把结果元素放在一个新的集合中，待进一步使用。 collect()方法的作用就是收集元素，收集的元素存放在呢，以什么形式存放，都是取决于其括号内Collectors调用的方法，如： *Collectors.toList()*就是将数据存放在一个List集合中，List的类型会根据数据格式自行匹配。 并行流 对于串行，最大的问题就是性能问题，随着计算过程越来越复杂、数据量越来越大，其工作模式性能会越来越低。而且其性能很难被优化，因为这种模式无法发挥多核CPU的优势 解决方法： 为了充分发挥多核CPU的优势，可以把串行计算模式，改为并行计算模式。所谓并行，就是利用多线程，变成同时执行。多线程可以充分发掘多核CPU的优势。 使用并行流的代码为,不再调用stream方法,改为调用parallelStream方法即可.其运行过程为: 因为并行计算使用多线程,每个线程独立输出数字,而线程的输出时机是由CPU动态决定的,无法确定,所以,逻辑上要求结果有顺序时,就不可以使用并行计算. 并行流的性能意外 并行计算模式的性能不是任何情况下都优于串行计算模式. 产生这种情况的原因有两种: 硬件太差 CPU核数很低,特别是单核情况下,并行计算模式不一定更好.因为多线程也要等待CPU资源,不能很好的发挥多线程的优势. 任务简单 数据量小,任务简单的情况下,并行计算模式不一定更好.因为线程的管理也要消耗CPU,内存等资源,可能比任务本身的开销更大. 两种模式的选择: 由于实际情况中,硬件,需求复杂度等各种因素比较复杂,所以实际上没有确定的选择方案. 一般来说,任务执行超过一小时的情况下,考虑使用并行模式优化性能. 任务执行时间较短,又没有特别要求,使用串行模式问题也不大. 对任务有实时性要求,希望立即得到计算结果,最好是比较一下两种模式. 常用设计模式 设计模式的作用 设计模式本身并不是java特有的，是有着丰富经验的优秀的程序员前辈们总结出来的最佳实践，经过时间沉淀，形成的一套解决问题的方法。 学习设计模式有助于提升代码的质量（重用代码、易阅读、易维护、可靠性、扩展性等方面）,也有助于提升程序员的设计能力。 单例模式 解决问题：保证一个类仅有一个实例。 核心办法：把构造函数设置为私有的。（把构造函数设置为private，就意味着，除了自己，其它任何类都不能实例化该对象） 例如： 在ClassMaster类中定义一个ClassMaster类型的变量，赋值为new出来的自己的实例。 必须使用static修饰符，否则会造成死递归的严重错误。 也就是说，不允许其它类实例化ClassMaster、只有自己能实例化一个唯一的自己（private static），所以可以保证ClassMaster的实例是全局唯一的。 这种可以保证只有一个实例对象的方式，就是单例设计模式。 Spring中的单例 类变量使用@Autowired注解，能够实现自动注入实例对象。 任何自动注入的实例对象，默认只有一个实例对象，是单例的。 Spring会保证只生成一个实例，注入到多个Service或Control中，不会为每个Service或Control分别new出多个实现类的实例。 简单工厂模式 现实生活中的“工厂”是生产产品的地方，而程序中的“工厂”是生产实例对象的地方。 根据不同条件创建不同的对象的核心问题是： 代码重复： 每个需要提供多种水果的商店都要写一堆相同的逻辑代码，如果要删除或者增加一个条件，那就是灾难。 耦合紧密： 当某一个对象内容要该更改时，那就要该很多地方，那也是灾难。 解决办法： 实现简单工厂，需要两个步骤： 从具体的产品类抽象出接口。Java强调面向接口编程，意味着工厂应该生产一种产品，不应该生产某一个产品。 把生产实例对象的过程，收拢到工厂类中实现。 如下图： 工厂仍然要实现功能，完成根据不同条件创建不同对象需求。 一般来说，工厂类命名为xxxxFactory，以Factory作为后缀可提高辨识度，易于理解这个类的作用。 使用简单工厂完成功能开发时，重点就是要明确什么条件下创建什么实例对象的需求逻辑。 抽象工厂模式 简单工厂适合创建一种对象，但有时候会遇到复杂的问题，需要创建一个系列、多种产品的时候，简单工厂模式就不太适合了。 例如： 餐馆、水果超市、甜品店除了提供水果外，可能还提供饮料 问题： 由于水果和饮料是搭配的、属于零食系列，比如五金店里就不卖水果、饮料等零食，所以对于餐馆，就需要知道哪些工厂需要搭配，这就导致餐馆与多个工厂耦合太紧，不利于扩展。 解决办法： 对于一批、多种类型的对象需要创建的场景，使用抽象工厂模式会更好。 简答工厂主要是把多个产品抽象，使用一个工厂统一创建； 抽象工厂的主要作用是把多个工厂也进一步抽象。 如下类图： 进一步的抽象出了工厂接口，然后多了一个SnacksFactoryBuilder。 工厂接口 工厂接口即规定工厂应该提供什么样的产品，所以包含了所以工厂的方法： 但有一个问题，水果工厂是不提供饮料的，但水果工厂实现工厂接口后，就必须实现getDrink()方法，这个时候直接返回null即可。 水果工厂不真正实现getDrink()方法，只是基于接口的需要，给一个没有实际作用的方法实现。 工厂的工厂 SnacksFactoryBuilder称之为生产工厂的工厂，工厂用来生成产品实例，SnacksFactoryBuilder用来生成工厂实例。 与简单工厂不同的是： SnacksFactoryBuilder的buildFactory()方法不是static的。 因为复杂场景下尽量不要使用类（static）方法，实例方法可以被继承，扩展性较好，应该优先使用实例方法。 工厂模式结合Spring工程 不提倡在工厂的定义static方法的另外一个原因是: 在使用Spring框架的时候,可以为SnacksFactoryBuilder加上@Component注解,可以让框架管理实例: 简单工厂模式的工厂类也可以像这样去掉static、加注解。 相应的，任何需要使用工厂的地方，只需要使用@Autowired注解让框架自动注入实例即可： 观察者模式 观察者模式的核心是要知道观察什么，什么对象发生变化了需要发出通知。 如： 在天气项目中，显然，天气信息是核心，天气发生变化了，需要通知大家都知道。所以，先抽象出天气信息对象。 天气信息类WeatherData继承了Observable类。Observable类是java提供的，继承了就表示是核心的、需要被观察的类。 这个设计与以前模型设计的不同的是，一个WeatherData代表一个城市的天气，初始化完毕以后就不能改了。所以去掉了所以属性的setter方法。WeatherData是被观察者。 时间和气温是监听的重点信息，所以增加一个新的方法来专门处理： 在changeTemp()中，如果天气数据与原来不同，则会标记变化并发出通知。 父类Observable提供的方法setChanged()就是标记被观察者对象发送了变化。 父类Observable提供的方法notifyObservers()就是发出通知；如果需要发送额外（不在被观察对象里的）的信息，在参数中传入信息对象，可以是任意对象，需要自己根据具体的需求场景而定。 需要了解天气的类，就是接受通知的类，通常叫作观察者。 观察者需要实现Observer接口，也是java提供的，实现此接口表示作为观察者。 作为观察者，实现Observer接口后，要自己实现update()方法，方法签名是接口中定义好的，属于固定写法。 第一个参数就是被观察者对象，被观察者对象都需要继承自Observable。 第二个参数就是额外的信息，具体说就是调用super.notifyObservers()时传入的参数对象；传入什么对象，arg的值就是什么对象。 如果不想发送额外信息，写为super.notifyObservers(null)，那么这里arg值就是null，注意避免空指针异常。 update()方法的作用就是接受通知。实际上，系统在super.notifyObservers()发出通知后，即调用所以观察者的update()方法，完成通知的过程。 观察者可以有多个。观察者对象与被观察者对象谁先new出来都可以，但是必须先调用addObserver()方法把观察者对象实例添加到被观察者实例中，然后再调用自定义的changeTemp()方法变更天气，才能触发自动通知。 类图如下： 跟工厂模式不同的是，观察者模式主要描述的是类的行为，而不是如何创建。 跟工厂模式的思想相同的是，观察者模式让观察者和被观察者双方的耦合度降到最低（称之为解耦） 并发编程 并发编程的原因： 节约时间。 计算机中，每个软件运行一次，即启动了一个进程。相当于整个泡茶的过程，是一个进程；而每个统筹方法工序，是一个个进程。统筹方法工序是工作模式，称之为多线程。 Spring中，启动一个SpringBoot项目，就是启动一个进程。而一个个用户访问首页的过程，都是一个个进程。SpringBoot项目的工作模式是多线程的。 继承Thread类 Java为多线程 编程提供了内置的支持。 实现 线程类 可以继承Java 的Thread类实现线程类。 Thread的完整类名是Java.lang.Thread。Java.lang包里的所有类都可以省略import。 继承Thread类后，需要重写父类的run()方法，必须是修饰为public void，方法是没有参数的。 加上@Override注解，会让系统自动检查public void run()方法定义有没有写错。 这里用Thread.sleep(200)模拟取钱的程。sleep()方法（静态方法）的作用是让线程睡眠、暂时不再继续执行，交出CPU，让CPU去执行其他的任务。sleep()方法的参数是毫秒数，200表示200毫秒，超过这段时间后再继续执行程序。相当于让程序休息200毫秒就完成取钱啦。 运行线程 线程需要调用start()方法才能启动。 类图如下： Thread父类中有name属性，但是是private的，所以可以调用setName()方法为线程设置名字，通过getName()就知道是那个线程在运行。 线程类的run()方法是系统调用start()后自动执行的，编程时不需要调用run()方法。但无法知道系统在什么时刻调用。（也就是说先start的线程，run不一定先执行） 实现Runnable接口 继承Thread类定义多线程程序后，缺点就比较明显，无法再继承其他类，因为Java是单继承的，只允许继承一个类，这会导致程序的可扩展性大大降低。 所以定义多线程程序，优先采用第二种方式：实现java.lang.Runnable接口。 改进代码： Runnable接口中只有一个待实现的run()方法，要自己补充属性。 无论是Thread类还是Runnable接口，run()方法都是系统适时自动执行的。 Thread.sleep()方法依然可以用。 实现Runnable接口的线程类，还需要包装在Thread类的实例中运行： Thread实例（new Thread(person1))相当于调度器，触发线程任务执行，线程类的实例（new Person())就相当于任务。任务不能自己启动的，需要被调度。 类图如下： 线程安全 Thread.currentThread().getName()中Thread.currentThread()返回当前正在运行的线程的实例对象。 当处理统一组数据（如买三十张车票）会出现明显的错误。 如： 问题一：车票余量是错乱的，甚至可以余量相同 问题二：余量是负数 分析： 线程的调用时机是复杂的，是可以同时执行的，特别是多核CPU的情况下，多个线程同时（也叫并行）执行的概率很高。 这种多个线程运行同一个实例对象的情况下，修改了同一个变量，后果是不可预料的。所以会出现余量打印错乱甚至相同的情况。 问题一的解决方案： 多个线程操作同一个资源的时候，发生了冲突的现象，就叫做线程不安全。 在java中，可以用synchronized关键字来解决余量错乱的问题。synchronized加载方法上，紧跟着public: synchronized也叫线程同步锁，表示此方法是锁定的，同一时刻只能由一个线程执行此方法。 synchronized相当于保护了关键方法，不允许同时执行，必须一个一个执行。 一个一个执行不是按照编码的顺序执行。由系统自动决定在解锁后由哪个线程执行方法，也是很复杂的。这种多个线程等待的过程叫作竞争。 问题二的解决方案 当车票余量为1的时候，四个线程可能同时判断是否调用，所以会出现负数。 所以对于出现问题的方法来说，必须保持逻辑完整性，不能依赖其他类的条件判断，自己就不判断了。 synchronized使用场景 使用synchronized的方法意味着满足了两个线程安全的特性： 原子性：方法全部执行并且执行的过程不会被任何因素打断。 可见性：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。 但是synchronized为了这两个特性，也付出了一定的代价：性能可能不高，因为方法加锁，同时只有一个线程竞争成功能继续执行，其他很多线程是持续等待、响应慢的。下面是适合其使用的场景： 写操作的场景。例如：用户修改个人信息、点赞、收藏、下单等。 尽量精确锁住最小的代码块，把最关键的写操作抽象成独立的方法加锁。不建议给大段的方法加锁。 悲观锁和乐观锁 java.util.concurrent是Java系统提供的并发编程包，尝试使用java.util.concurrent.atomic.AtomicInteger让车票余量能够安全的递减。 这里sell()不再加锁，解决了车票余量重复的问题。 AtomicInteger虽然是一个类，但等同于一个整数。调用new AtomicInteger() 构造函数实例化对象的时候，可以指定任意的整数值。 new AtomicInteger(30)意思是设定实例的整数值为30. 不同的是，AtomicInteger提供了不使用synchronized就能保证数据操作原子性的方法。如下： decrementAndGet()方法是三个操作的组合，多线程情况下也不会出现数值重复的错误，证明这三个操作是密不可分的、线程间没有互相干扰打断，保证了数据的正确性。这就是类名Atomic-原子性的含义。 线程间都是基于最新的结果进行减一的运算，所以不会重复，这样是可见性的体现。 但是对于车票余量出现负数依旧没有解决，而且打印顺序也可能出现错误。这是因为条件判断语句、操作语句、打印信息语句组合起来，就不具备原子性了，因为sell()不加锁，多条语句执行时就可能被其他线程打断了。 所以必须给sell()整体加synchronized才能保证多条语句整体的原子性。 案例： 春蕾中学新生入学报名的时候，会自动获得一个学号。相当于多线程并发情况下，要保证学号不能重复。 核心代码： 类图： incrementAndGet()和decrementAndGet()都没有加synchronized关键字： 这就意味，递增、递减等方法虽然也是多个步骤，但多线程场景下，其他线程不会等待。只是在数据变化的时候，会判断一下是否有其他线程修改了数据，如果有就根据最新的值进行修改。 这就是乐观锁的一种表现。 java.util.concurrent.atomic.AtomicInteger能够以原子的方式操作整数， java.util.concurrent.atomic.AtomicBoolean能够以原子的方式操作布尔值。 AtomicBoolean是boolean的包装类，AtomicBoolean的实例等同于一个布尔值： new AtomicBoolean(true)等同于true new AtomicBoolean(false)等同于false 取布尔值： 修改： compareAndSet(true,false)判断当前值为true时，修改为false，然后返回成功或失败。 compareAndSet(false, true)判断当前值为false时，修改为true，然后返回成功或失败。 其返回值表示修改操作成功或失败，与方法参数无关。 乐观锁其实是不上锁，总是保证基于最新的数据进行更新。由于没有上锁，就提高了性能。不上锁的思想是乐观的，所以称之为乐观锁。 AtomicInteger类的incrementAndGet()和decrementAndGet()方法就是典型的乐观锁实现。 相对的，synchronized关键字是把整个方法执行前就上锁，假设其他线程一定会修改数据，所以提前防范。上锁的思想是悲观的，所以称之为悲观锁。 区别总结： 乐观锁：不适用于多条数据需要修改，以及多个操作的整体顺序要求很严格的场景，乐观锁适用于读数据比重更大的应用场景. 悲观锁：适合写数据比重更大的应用场景。一般来说写数据的整体消耗时间更长些，是可以接受的。 并发容器 多个任务有前后的顺序，但后继的任务不必等待所以前置的任务全部完成后再执行，而是每个前置任务完成后，自动执行对应的后继任务。这种场景下，适合用java8的CompletableFuture特性来解决。 CompletableFuture应用 CompletableFuture是一个异步任务编排、调度框架，以更优雅的方式实现组合式异步编程。 在方法调用的时候，需要等待返回取得返回值是同步，不等待而继续执行程序代码就是异步。采用异步方式，能够支持多个任务并行执行，这种机制称为并发。 类图： Register类重构 获取学号的Register类不必实现多线程接口： 并行注册 CompletableFuture.supplyAsync()方法运行一个异步任务并且返回结果，所以regId()方法必须有返回值。 Register虽然没有实现Runnable接口，但系统会自动优化：把作为**supplyAsync()*方法参数的整个()-&gt;reg.regId(s)*表达式语句包装在另外一个对象中；这个对象也是JDK内置的，它实现了Runnable接口，在这个对象中执行表达式语句。 所以，supplyAsync()方法的作用是：在一个单独的线程中执行reg.regId(s)语句，本质上就是多线程编程。 在注册完毕后，使用thenAccept()方法完成后继的任务步骤。thenAccept()方法的参数（student）就是前置任务的返回结果，系统会在前一个任务完成后，自动执行student-&gt;{}后继任务。所以本质上，后继任务也是多线程方式执行的。thenAccept()方法通常用于任务链的末尾。 CompletableFuture VS Stream parallelStream() 他们都使用了多线程并发编程，都可以称为并发容器。 不同的是：Stream parallelStream()侧重点是流的元素的计算操作； CompletableFuture的任务可以比较宽泛。 当然，不是每个任务都只有两个步骤。 多步骤任务 班级分配类： 为学生类增添一个classID属性： 任务执行 supplyAsync()用于开头，thenAccept()用于末尾，各自调用一次即可。中间有多个步骤，可以调用多次thenApply()。注意各步的返回值类型。 流程图： 对于多个任务之间，是并行的，使用多线程同时执行多个任务； 而对于一个任务的多个步骤，是串行的，必须先执行完前一步骤才能执行下一步骤。 扩展知识点：返回值 supplyAsync()是静态方法，返回值是CompletableFuture实例对象，再调用thenApply()或者thenAccept()实例方法，返回的也是CompletableFuture实例对象。 所以，虽然整条语句是连写的，其实也可以定义返回值。 返回的仍然是CompletableFuture实例对象，所以定义变量的类型就是CompletableFuture。但可以使用泛型CompletableFuture&lt;&gt;表示其中包含的数据具体是什么类型。 因为本案例末尾调用了thenAccept()，其Lambda表达式没有return语句，表示CompletableFuture实例对象不包含数据，所以泛型写为CompletableFuture. 返回CompletableFuture类型 如果没有调用thenAccept*(）方法，以thenApply()或者supplyAsync()结尾的话： 因为thenApply()的Lambda表达式返回的是Student对象，所以CompletableFuture实例对象包含的是Student数据，于是泛型写为CompletableFuture。 这几个方法返回的是CompletableFuture实例，但其实包含什么类型的数据取决于Lambda表达式返回值的类型，如果没有返回值，则用表示。 扩展知识点：main()方法的问题 目前我们的程序，都是通过main()方法执行的。如果学生人数较多，所有注册线程的运行就没有那么快完毕了。可能线程任务还没有执行完毕，main()方法就执行完毕，导致程序结束退出了。 要解决这个问题，返回值就有用了。我们先把每个学生的入学任务实例对象（CompletableFuture),收集起来（装入集合），然后等待所有的线程执行完毕。 CompletableFuture.allof()是静态方法，作用就是收集所有的任务实例对象。因为allof()方法只支持数组不支持集合，所以需要把集合转换成数组（cfs.toArray(new CompletableFuture[] {})).也可以一开始就定义数组来收集任务实例对象，因为学生的个数可以通过studentList.size()取得。allof()方法的返回值也是CompletableFuture实例对象。 再调用类方法get()，其作用就是等待所有的任务线程都执行完毕，再继续执行。 在SpringBoot等服务端运行supplyAsync()异步任务编排的时候，就没有必要等待所有线程任务执行完毕了，因为服务端往往是常驻程序，不像main()方法执行完毕就退出程序了。 线程池 使用Runnable接口开发多线程程序，更符合面向对象的习惯，但是随之而来的问题是，对象太多了。 如下例子：（4位同学注册的场景） 在现实中，入学人数肯定不是4个这么少，如果有一千位同学入学，就意味着程序要额外new Thread(register)一千次。对象除了创建需要消耗计算机CPU、内存等资源，对象还会被销毁，销毁也是要消耗资源的。 为此需要使用线程池技术 线程池基本概念： 所谓线程池，顾名思义，就像一个池子，里面装满了线程，随用随取。线程可以被复用，一个线程，可以执行A任务，也可以执行B任务，于是线程不再频繁创建和销毁。 new Thread(register)意味着一个线程对象只能执行一个任务，而线程池让线程与任务分离，不再紧密绑定。 线程池的另外一个重要概念是，线程池并不是无限大的，所以线程池中存在的线程数也是有限的，这就意味着能同时运行的任务数也是有限的，其他过剩的任务就需要排队。等其它任务完成后，有空闲的线程后，才能继续执行任务。 线程池创建 创建线程池的核心代码是： 这里的BasicThreadFactory需要依赖一个库： 解释： 创建线程工厂实例 需要注意的是，namingPattern()方法是定义线程名字的格式，相当于线程名称模板，根据具体业务需求把&quot;studentReg&quot;改掉。 Builder()不是方法，是构造函数，BasicThreadFactory类中有一个内部类Builder。 创建线程等待队列实例 线程池没有空闲的线程时，其他的任务，就需要在队列中等待。 如果机器性能好，CPU核数多，队列可以大一点：new LinkedBlockingQueue&lt;Runnable&lt;(2048).构造函数的参数表示能排队的任务个数。 创建线程池实例 ThreadPoolExecutor构造函数参数较多，七个参数按顺序说明如下： ![](../photo/屏幕截图 2022-03-25 174342.png) 多线程编程特别需要注意的问题是：防止线程数过多把系统搞崩溃。所以用线程池可以做更加精确的控制，否则难以控制、无法保证稳定。 使用线程池运行任务 参考类图： 只要执行线程池对象的**execute()**方法，把实现了Runnable接口的实例对象传入即可。 线程池与并发容器 多线程编程到底要用什么： 实际上，CompletableFuture内部也用到了线程池。 实际上是把任务放在内部的默认线程池里执行的。 CompletableFuture也可以指定线程池来运行任务： supplyAsync()方法可以有第二个参数，传入我们创建好的线程池对象。那么任务就是用指定的线程池而不是默认的。 技术的先进程度为： 基础多线程 ——&gt; 线程池 ——&gt;并发容器 指定线程池的场景 学习阶段一般来说，直接使用supplyAsync(()-&gt;{})就够了。在企业中，遇到任务并发度高、任务量大、任务执行慢的情况下，就需要指定线程池，严格控制线程任务了。 或者一开始使用CompletableFuture默认线程池，当发现任务执行慢，任务堆积的问题时，就要考虑指定线程池，并调整线程池参数。 ","link":"https://jiuxiazz.github.io/post/bing-fa-kai-fa/"},{"title":"Web","content":"Web前端开发 什么是前端开发 前端开发是创建Web页面或APP等前端界面呈现给用户的过程，通过HTML、CSS及JavaScript以及衍生出来的各种技术、框架、解决方案,来实现互联网产品的用户界面交互。 前端三把斧 HTML、CSS、JS HTML(HyperText Markup Language) 超文本标记语言，由物理学家蒂姆·伯纳斯-李提出并创建，是一种用于创建网页的标准标记语言。HTML描述了一个网站的结构，是一种标记语言而非编程语言。 CSS(Cascading Style Sheets) 层叠样式表，又名串样式列表、级联样式表、串接样式表、阶层式样式表，是一种用来为结构化文档添加样式的计算机语言，它的主要职能就是确定布局和元素的表现。他不可以单独使用。 JavaScript JavaScript是一种高级的、解释型的编程语言，它能使网页可交互，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。 HTML元素的结构 HTML标签 由尖括号包围关键词组成，比如：&lt;p&gt;、&lt;h1&gt;、&lt;div&gt;、&lt;span&gt;等； 通常成对出现，比如&lt;div&gt;和&lt;/div&gt;，第一个就是开始标签，第二个就是结束标签，要注意开始标签和结束标签的区别在于，结束标签比开始标签多一个“/&quot;； 虽然标签通常是成对出现的，但不并不是所有标签都有对应的结束标签，比如&lt;input&gt;、&lt;img&gt;等，它们往往是单独呈现的； 一个标签就是一个元素 HTML中的嵌套 在HTML中，元素可以发生嵌套，例如： 此时，div元素就是p元素的父元素，而p元素是div元素的子元素。 完整的HTML文档结构 下图就是一个完整的HTML文档： &lt;!DOCTYPE html&gt; 作用：告知浏览器该页面文件的文档类型，指示web浏览器使用哪个HTML版本编写页面。 位置：声明必须是HTML文档的第一行，位于&lt;html&gt;标签之前。 该声明对大小写不敏感。 该声明没有结束标签。 &lt;html lang=&quot;en&quot;&gt;....&lt;/html&gt; 此元素可告知浏览器其自身是一个HTML文档。 &lt;html&gt;与&lt;/html&gt;标签限定了文档的开始点和结束点，在它们之间是文档的头部和主体。文档的头部由&lt;head&gt;标签定义，而主体由&lt;body&gt;标签定义。 lang属性（语言属性）：当搜索引擎或者浏览器拿到语言属性后，有可能做一些针对指定语言的辅助操作，‘en'表示英文。 标签属性 标签可以拥有零个或多个标签属性，注意：标签属性与标签名称、标签属性与标签属性之间需用一个空格隔开。 标签属性可以赋予标签更多的信息，标签属性通常是以key=&quot;value&quot;即名称=“值”的形式出现。 常见的标签属性有：class、id、style、lang、src等。 文档的头部&lt;head&gt;.....&lt;/head&gt; head元素定义文档的头部，我们通常在这里引用样式表、提供元信息等。 文档的头部中的&lt;title&gt;.....&lt;/title&gt;定义文档的标题，在网页上体现为网页标签的标题。 一个&lt;head&gt;元素必须包含且只能包含一个&lt;title&gt;元素。 元信息:又叫元数据，就是描述数据的数据。这里主要指文档的概要信息。 文档的主体&lt;body&gt;....&lt;/body&gt; body元素定义文档的主体，包含文档的所以内容（比如文本、超链接、图像、表格和列表等等）。 HTML中的注释 在HTML中，我们使用&lt;!-- --&gt;标签来表示注释： HTML—文本标签 块状和内联标签 两种最大的区别：块状标签会为自己的内容占据新的一行，而内联标签则不会。 常见的块状标签：&lt;p&gt;、&lt;h1&gt;、&lt;div&gt; 常见的内联标签：&lt;span&gt;、&lt;img&gt;、&lt;strong&gt; 标题标签 标题标签为&lt;h1&gt;~&lt;h6&gt;,下一级标题是上一级标题的子标题，一级标题后可以有多个二级标题。 注意：标题之间不可以越级，比如一级标题下直接写三级标题，这样会导致文章失去清晰的文章结构。 效果图为： 常用文本标签 &lt;p&gt; （块状标签）代表文章的一个段落。 &lt;strong&gt; (内联标签) 包裹内容加粗 &lt;b&gt;也可以加粗，但我试的时候没看出来（后者没有语义） &lt;span&gt; (内联标签) 包裹内容不会产生换行，常在句尾包裹人名 图片标签 &lt;img src=&quot;&quot; alt=&quot;&quot;/&gt; 在标签里，src后面写入图片的相对路径或绝对路径，alt这个属性是描述图片的替换文本，就是说当URL是错误的或者图片不在支持的格式列表中或者图片没有被下载，导致显示不出来图片，这时用户就会看到这里的替换文本。 链接标签 &lt;a href=&quot;&quot; title=&quot;&quot; target=&quot;&quot; &gt;***&lt;/a&gt; 是一个内联标签，用户点击后，浏览器会跳转到指定的网址。其中href这个属性后面的就是要跳转的网址，title属性给出链接的说明信息即鼠标悬停在链接上方时，浏览器会将这个属性的值以提示块的形式显示出来，target属性指定如何展示打开的链接，它的值可以是“_self”、“_blank”、“_parent&quot;、&quot;_top&quot;、&quot;&lt;XML-Name&gt;&quot;其中默认值为self，它表示当前页面打开，blank表示在新页面打开，后两个有点复杂，简单的说和self差不多,最后一个和blank差不多，***就是显示出来的字或者图片。默认字体为蓝色带有下划线。去掉下划线的方法text-decoration:none. target属性值的具体区别： 列表 列表分为无序列表和有序列表，列表的每一项都用标签&lt;li&gt;表示。 列表有个属性list-style：none可以去除li标签前面默认的小圆点。 form标签（交互式标签） &lt;form action=&quot;&quot; method=&quot;&quot;&gt;***&lt;/form&gt;标签是一个块状元素，这个标签里面有两个属性action和method： action:一个处理此表单信息的程序所在的URL，所述表格信息将在表单提交时被发送到定义的地址； method：它的值可以是GET或POST，用来规定如何发送表单信息至服务器。 单行文本输入框 &lt;input type=&quot;text&quot; placeholder=&quot;&quot; name=&quot;&quot; value=&quot;&quot; readonly(disabled) /&gt; input是一个内联元素，而且还是个只有开始标签，没有结束标签的内联元素，它内部的属性： placeholder: 这是一个占位文本，原本输入框为空白的，但有了这个属性，文本框内会出现该属性的值，在点击输入框时，这个值会消失，是用来提示用户需要输入什么的。 name:输入框的名字，给输入框定义一个名字，这样在提交表单数据时就不会和其他的&lt;input&gt;搞混了 value:输入框的值，给输入框填写一个默认的值，这个值可以删掉，是真实输入到文本框内的值。 readonly(disabled):定义输入框不可修改，这俩值二选一即可，他们都是使输入框不可修改，但有区别： readonly：它只可以用于input和textarea这两个对象，它仅使文本框不能输入，外观上也没有变化 disabled：它可以作用于所以表单元素，可以使文本框不能输入，当表单以POST或GET的方式提交时，使用了disabled的元素的值不会被传递出去，它会使文本框变灰。 多行文本输入框和密码输入框 &lt;textarea name=&quot;&quot; rows=&quot;&quot; cols=&quot;&quot; placeholder=&quot;&quot; &gt;&lt;/textarea&gt; 多行输入框和单行的区别，多行的在输入内容超过一定长度时会自动换行，而单行的不会。它的属性：rows和cols分别表示行数和文本域的可视宽度，这俩可写可不写，placeholder和单行里面的用法一致。 &lt;input type=&quot;password&quot; ....../&gt; 密码输入框可以使用户输入的内容以黑圆点的形式显示，密码输入框和单行输入框只有type属性的值有变化，其他的都不变。 单选框和复选框 &lt;input type=&quot;radio&quot; ..../&gt;单选框和单行框只有type属性后面的值不同，它的显示效果为一个空白圆圈，不能同时选择多个小圆圈，value属性的值不会显示在圆圈后面，只是提交时提交的内容，想要在圆圈后面显示内容，需要在&gt;后面加上想要显示的值,且input元素需要被label包裹例如：&lt;label&gt;&lt;input type=&quot;radio&quot; /&gt;男 &lt;/label&gt;这时圆圈后面就会有个男字。想要在圆圈后显示内容，还有一种写法： 给input加上id属性后，再给label加上for属性，两者值一致的时候就产生一一对应的关系了。 &lt;input type=&quot;checkbox&quot; /&gt; 他和单选一样，只有type属性的值不同，显示效果为一个空白小方框，可以同时选择多个小方框。使用方法和单选框一样。 注意：属于同一道选择题的每个单选按钮，应该拥有相同的name属性值。 复选框有两种状态的表单控件，已选中或未选择。在只有一个复选框时，它允许用户对某事说“是”或“否”，而只有一个单选框时，用户一旦选择了，就不能取消选择，除非刷新网页。 选择菜单 value属性的值是提交时提交的内容，***是选择框内显示的值，如果加上multiple，则这个选择框在按住Ctrl键时可以多选。 按钮 &lt;button type=&quot;submit&quot;&gt;按钮&lt;/button&gt;不加type也可以，但由于兼容性的原因，部分不能起作用，还是加上保险。按钮两字可以被其他文字，图片等代替。 输入浮点数的控件 &lt;input type=&quot;number&quot; /&gt;会生成一个输入框，可以输入浮点数，也可以以1为单位的加减。不能输入汉字和英文。 CSS--美化文档 HTML内部添加样式 声明字段style=&quot; &quot; 这段代码要写在各元素开始标签内部，由属性和值组成，内部字段用:隔开，用分号；收尾，与其他属性要用空格隔开，顺序没有要求。内部字段： font-size:**px; 设置字体大小，单位为px。 font-weight:100;设置字体粗细，值可以是100,200,等等也可以用英文，normal（正常粗细），lighter（细），bold（粗），bolder（更粗） color： ；设置颜色，值可以是英文black，blue等等，也可以是十六进制颜色#DAEADA等，还有rgb形式rgb（222,111,212）；还有rgba形式rgba（111,222,333,1.0）； 英文：这个就是正常颜色的英文拼写。 十六进制颜色：由#开头，后面三个数字，每个数字的范围为00~FF，每个数字代表一种颜色，最终颜色为这三种颜色的和，这个不需要死机，项目文档里面会有。 rgb形式：和十六进制相似，范围为0~255，r(red),g(green),b(blue)三个数字分别代表每种颜色的深浅，值越大颜色越深。 rgba形式：比rgb形式多了个a，a代表透明度（Alpha)，a的值在0~1之间，可以省略掉0，如0.5，可以直接写成5，值越小越透明。 text-align： ；设置文字对齐方式，center为文字居中对齐，left为文字左对齐，right为文字右对齐。 line-height:**px; 设置行高，行高减去字体大小再除以2得到的就是字体与上下边线的距离，当行高和矩形的高度一样时，文字就好上下居中。 font-family: ; 设置字体，这个属性的值可以有多个，在加载的时候，页面会一次检查电脑是否安装该字体，如果有就用，如果没有，就使用默认的微软字体。字体件要用英文逗号隔开，如果字体名称中有空格，需要用引号引住，如果为中文名称字体，只需要用空格隔开。 在CSS中可以使用**calc(100%-20 px)**这种方式计算属性值 CSS的引入方式 CSS有三种引入方式： 行内样式：每一行都写一个style，这种的比较繁琐，工作量很大。 内部样式： 首先要把每一个标签里面的CSS样式抽取出来 然后在head标签内声明一个&lt;style&gt;&lt;/style&gt;标签 最后把样式都放在style标签里。 将相同标签的样式写在相同的大括号里，大括号前面加上标签名。 外部样式：当代码量的增多时，整个HTML文件就会出现头重脚轻的现象，即CSS代码要比HTML代码多得多，为此我们对代码进行进一步的分离。 新建一个index.css文件 将HTML代码头部中的style标签内的样式全部拷贝过来 将复制的css样式粘贴进index.css文件中 建立HTML和CSS文件的联系，即用link标签引入CSS文件 link标签一定要在head标签内，形如&lt;link rel=&quot;&quot; type=&quot;&quot; href=&quot;&quot; /&gt; rel:rel属性规定了当前文档与被链接文档之间的关系，但是rel属性的stylesheet值被所有浏览器支持，记住这个就够了。stylesheet意思就是文档的外部样式表。 type属性规定了被链接文档的MIME（多用途互联网邮件扩展类型），type属性对应的最常见的值就是text/css，该类型描述样式表。 href属性后跟的是要引入的链接地址，css文件的位置。 关于css代码中的注释，它和HTML中的不同，为/* 。。。。*/ 常用选择器 标签选择器：使用标签名字将标签选中，然后给标签中的文字设置字体样式。会给同类型的所以标签施加样式，如果重复写一个标签，则会导致：添加新的效果（之前没有的），改变之前已存在的效果。（选择器的层叠性） 类选择器：在元素的开始标签内定义class=&quot;&quot;,引号内的内容为类名，在使用时形式为用.(点)+类名代替标签选择器的标签名，其他一致。还有一点要注意，一个标签内可以添加多个类名，类名之间用空格隔开。 id选择器：和类选择器差不多，把类选择器class改为id即可，使用时为#+id名不同点为，id选择器在文档中只会出现一次，就像身份证一样，每个标签的id都是不同的，而且不能像类选择器那样存在多个类名。 属性选择器:使用时为[]括号内可以是某一特定的属性如:disabled,则会选中所以属性中带有disabled的标签,在括号的前面也可以加上某一个标签名,表明查找有该属性的该标签,同时在括号内还有两个特定的符号^=和$=前者表示已某一值开头,后者表示以某一值结尾. 高级选择器 后代选择器：形如p a,解释：选择所有p标签内的所以a标签，注意点需要用空格隔开。 交集选择器：形如a.apple{}，解释：在所以a标签内，类名为apple的标签 子选择器：形如p&gt;span{}，解释：在所以p标签下一级的span标签，如果是： 则只有qwe被选中，想要选中asd则应该改为p&gt;span&gt;span{}此时qwe是不会被影响的。 并集选择器：形如.box,p,h2,.phone{}解释：给类名为box、phone标签名为 p、h2的标签添加相同属性。并集选择器就是给不同的标签或者不同类名的标签添加相同的格式。 选择器的优先级 常用选择器的优先级（单个）：id选择器&gt;类选择器&gt;标签选择器 高级选择器的优先级：这里需要用到选择器权重的叠加性，优先级越高的权重越大，假如id选择器的权重为100，类选择器的权重为10，标签选择器的权重为1，（权重计算是不会越位的，一个id选择器比10个类选择器的权重都大，前面只是假设，而且一般也不会出现10个同种选择器的）权重大的会决定内容的属性。 额外补充一个知识点，文字属性的继承性：文字的属性会继承离他最近的一个父类标签。 属性的决定是由权重+继承性，两者的和来决定的，但对于直接选中的标签，它的优先级为最高。例如：在ul下有个p，现在选中ul，改字体颜色为red，另外还有个选中的p，改字体颜色为green，此时p标签的颜色为green，而不是red。 盒模型 &lt;div&gt;标签是一个干净透彻的矩形，没有默认的content、margin、padding、border、content，像淘宝那样的一个一个商品框，就是一个个的格子。下面一个个属性进行解释： content:div标签默认是没有高度的，但如果放在标签内，由于继承性，会继承父类标签的高和宽，设置高和宽：width（设置宽），height（设置高）单位均为px，在高和宽都设置完后，直接运行你也看不到这个矩形，因为它默认是没有颜色的，需要使用background-color这个属性设置背景颜色。 关于div套div，这里会牵扯到一个百分比尺寸，就是子标签的格式在width和height后面用百分之记录，则效果会按父标签的百分之多少显示出来。 padding: 设置内边距，即文字与边框之间的距离，，单位为px，默认值为0，单一个padding，会给四周添加相同的边距，如果想要给不同边，添加不同的边距可以用：padding-top、padding-right、padding-bottom、padding-left分别设置不同的边的边距，还有一种方法写:padding:20px 20px 20px 20px；分别为上，右，下，左;如果上下一样，左右一样，也可以写:padding:20px 30px；如果上下不一样，左右一样，可以写:padding:20px 10px 30px；其他情况不可以，从上面可以看出来，上下是一对，左右一对，padding后面的顺序是不会变的。 box-sizing:规定如何计算一个元素的总高度和宽度，其值有两个，content-box和border-box,默认值为content-box，其中，content-box尺寸的计算公式为：width=内容的宽度，height=内容的高度；border-box尺寸的计算公式为：width=border+padding+内容的宽度，height=border+padding+内容的高度；第一种算法中不包括border和padding，所以当子宽高占比100%时，再设置border和padding会超出父矩形，而第二种不会，第二种的width和height的值或者百分比都是加上border和padding后的宽高。 border：给矩形设置边框线，其属性： border-width：设置边框的粗细，单位是px。 border-color：设置边框的颜色。 border-style：设置边框的线框，solid为实线，dashed为虚线。（还有其他的，这两种最常用） 也可以省略写，写法为：border:**px solid blue;这三个值要用空格隔开，顺序可以忽略。还有一点，该属性也可以给四条边设置不同的效果，依然用top、right、left、bottom但是需要夹杂border和width之间，例如：border-top-color等等，对于省略的写法为：border-top：**px blue solid.对于那些只有一边效果不同的，可以利用叠加性来完成，先写全部的格式即border：.....然后再给特殊边设置效果，这个要注意先写的效果会被后写的效果覆盖。 无边框：可以用border：none;一般是个别边会设置无边框，所以可以用border+无边框的边来完成设置。 border-radius:设置圆角，单位为px，值越大，角越圆滑，它和前面的属性也有相似的，即可以给四个角分别设置，但只有左上、左下、右上、右下四个，分别为top-left、bottom-left、top-right、bottom-right四个，完整的写法为：border-top-left-radius其他的同理。 box-shadow：设置阴影，如下： box-shasdow:2px 2px 2px 1px rgha(0,0,0,0.2);后面的值分别为：x偏移量、y偏移量、阴影模糊半径、阴影扩散半径、阴影颜色。其中： x偏移量：在x轴上移动，向右为正 y偏移量：在y轴上移动，向下为正 阴影模糊半径：就是边线的清晰度 阴影扩散半径：就是向外伸展 阴影颜色：就是矩形下面那个矩形的背景 margin:设置外边距，即矩形与矩形之间的距离，单位为px，它和padding用法一样，可以设置各个边的距离，当设置两个矩形的距离时，可以设计一个，另外一个不设置，优先设置靠上面和靠左边的矩形。还有个作用就是使盒子在父盒子中左右居中，前提是子盒子必须有宽度，格式为：margin：**px auto; display:改变元素性质，即块元素和行内元素的性质转变，关于块元素和行内元素，一个最明显的区别，块元素独占一行且宽和高设置无效，行内元素可以与其他行内元素共处一行且可以设置宽和高，行内元素默认的display是inline，块元素默认的display是block，所以当该值改变，就可以使块元素能设置宽和高，也可以使行内元素不能设置宽和高，同时当display的值改为none时，该盒子将不显示。同时，行内元素可以设置padding，但它和块元素的padding还是有区别的，行内元素的padding设置后，可能出现和下一行的元素重叠，例如： 但当把行内元素改为块元素，则不会出现这种现象。行内元素还可以设置margin但是只能设置左右的margin，不能设置上下的margin。另外display还有一个值inline-block这个可以理解为可以在同一行显示的块元素。如果想要两个改后的div在同一行紧挨着呈现出来，则两个div之间不能有回车，这里的回车会被认为是字母，会使两个div之间出现一个小空白，还有两种解决方法，第一个，给父元素添加word-spacing属性（单词和单词之间的距离)，且把值写成负值，第二个，父元素设置font-size：0px。 在写项目的时候可以先用下面的代码来消除浏览器的一些基本格式。 定位 static（静态定位）：这个是position的默认值，也就是元素在文档流中，不加操作的默认位置定义方式。 relative（相对定位）：保留元素在文档流中的默认位置（相当于还在原位置，只是显示效果发生偏移），通过top、left、right、bottom四个属性，来改变元素距默认位置的距离，top即距离上，向下偏移的距离。 absolute（绝对定位）：不保留元素在文档流中的默认位置（即下面的元素会顶上来，代替该元素来占据这个位置）也是通过top、right、bottom、left四个值来改变位置的。它的位移是相对于离他最近的非static定位祖先元素（祖先元素即它的父元素以及更高位的元素）。 fixed（固定定位）：不保留元素在文档流中的默认位置，它是相对于窗口移动，窗口的滚动，不会影响它相对于屏幕左上角的位置，默认z-index为0，（z-index决定着元素所在图层的图层优先级，其值越大，优先级越高，位置越靠上，靠近用户，同值，则在HTML文件中，位置越靠下，越靠近用户，非static的值为0）。 sticky（粘性定位）：保留元素在文档中的默认位置，在含有该元素默认位置的界面里，和static没有什么区别，但当窗口滚动，到了规定的位置（即top、left、bottom、right这四个值规定的元素的位置，这个位置是相对于窗口的，和fixed定位相似），它就会和fixed定位一样固定在那个位置。 渐变色 background:linear-gradient(to right(渐变方向), color1(开始颜色) , color2(结束颜色)) 渐变方向: to right/to left 向右/向左渐变 to top / to bottom 向上/向下渐变 to right bottom / to right top 向右下/向右上渐变 to left bottom / to left top 向左下/向左上渐变 ×××deg ×××范围（0到360） 更加精确的渐变方向 渐变的开始和结束位置： 在每个颜色后面加一个百分比，就可以约定变色起止位置。 多种颜色渐变： 只是在括号内设置多种颜色。 设置硬线： 当两种颜色设置的结束位置一样时，就会在此位置设置一条硬线，使两种颜色不发生渐变，而是按原颜色发展到该位置，如果是多种颜色，则中间的颜色会被吞没。 渐变提示： 设置渐变中心位置，默认为50%，可以通过在两种颜色中间设置百分比来改变渐变中心。 背景图片 background-image:url();其中URL里面可以是远程地址，也可以是本地地址。不需要用“”引住。 如果引入图片长宽任意一项小于容器的长宽，那么浏览器就会让图片重复，知道铺满整个容器位置，想要让图片不进行重复，需要使用background-repeat:no-repeat，其中no-repeat还可以是repeat-x，repeat-y，repeat,这四个分别为：不重复，只在水平方向重复，只在垂直方向重复，在水平和垂直方向都重复。 改变图片在整个容器的位置，需要使用background-position:;它的后续值有三种： top，bottom，left，right，center，这五个值中left和right负责水平方向位置，剩下的负责垂直方向的。这两个方向中每个选一个，垂直在前，水平在后。 x% y% ，其中第一个是水平位置，第二个为垂直位置。 xpx ypx ，同2。 background-position还可以在position后面加上-x或者-y，从而规定位置，-x相当于top，-y相当于left，不写相当于center（此时后面只跟一个关键词）。 想要改变图片的大小，需要使用background-size: ;这个属性可以跟四种值： cover：使图片完全覆盖背景区域，即不管是x还是y都要覆盖完全。 contain：使图片尽可能的放大，使其中一边完全覆盖背景区域。 xpx ypx：手动设置宽度和高度 x% y%：按百分比手动设置宽度和高度。 简洁的写法为： 不需要加中括号，没有值就直接置空。 第四个和最后一个分别为：背景是否跟随窗口滚动而滚动；背景是否延伸至边框，内边距盒子，内容盒子下面。 Web进阶 HTML5 HTML5简言之就是HTML的升级版，在之前的基础上添加了更多的功能，丰富了一些属性，让页面制作更加多元化，相比之前的HTML而言，HTML5功能更强大、页面效果更加绚丽。 在HTML5中，可以仅通过阅读代码，来确定页面结构，新增了许多语义化标签，他们如下： CSS伪元素--::after/::before 伪元素就是利用CSS代码在标签内部的前面，或者后面添加一个内元素，这个行内元素可以理解为span before伪元素就相当于在添加伪元素的标签前加上一个行内元素（这个可以通过设置display来改变） after和before相，只不过这个是加在元素后。 CSS伪类--清除浮动 对于浮动（float）常常会脱离父元素控制，变成自由元素，为了父元素可以包裹住浮动的子元素，我们可以使用清除浮动操作来实现。 我们需要在父元素中加上： CSS伪类--事件伪类 hover--鼠标移动上去 active--鼠标点击时 用法同上，但要注意一点，当两者同时使用于一个元素，需要先声明hover再声明active要不然不会生效。 focus--获取焦点后 用法同上 CSS伪类--列表伪类 匹配ul中的每一个li 匹配其父元素中的第一个子元素--:first-child 注意一点，这里的选择器选定的是子元素li而不是ul。 匹配父元素中最后一个子元素--:last-child 用法同上 匹配父元素中的第n个子元素--:nth-child() 括号中跟要选定的元素的索引，除此之外还可以写两个特定的单词odd（奇数），even（偶数） 列表伪类的适用范围不止ul和li，其适用条件是：同一级别，相同元素。 CSS装饰--cursor cursor是控制鼠标箭头变化 其变化有特别多，其中常用的是pointer，更多变化查看MDN文档 CSS装饰--box-shadow/text-shadow box-shadow-----盒子阴影 盒子阴影的形成原理就是在盒子下面的另一个盒子改变样式或者位置造成的现象。 盒子阴影不一定只设一个，也可以对同一个元素设置多个阴影，在css中，任意数量的阴影，以逗号隔开参数。 text-shadow-----文字阴影 文字阴影和盒子阴影一样，文字阴影就是文字下面还有一层相同的文字。 CSS Flex布局 flex布局有强大的空间分布和对齐能力，可以很容易解决传统布局中比较难解决的布局问题。 传统布局，即基于盒模型，依赖display属性、position属性、float属性进行布局。 什么是flex Flex是Flexible Box的缩写，意为弹性布局，用来为盒装模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。 它最显著的效果就是把原本从上到下排列的块状元素变成水平排序 设置法为：对父元素设置display： flex 设为Flex布局后，子元素的float、clear和vertical-align属性将失效。 采用Flex布局的元素，称为Flex容器，简称“容器”。它的所以子元素称为Flex项目，简称“项目” justify-content和align-items 在flex布局中控制水平方向分布的属性为justify-content。 调节水平方向的分布justify-content justify-content有六个有效值 1. 调整垂直方向上的分布align-items align-items有五个有效值： flex-wrap 默认情况下，项目都排在水平方向上，并且是单行排列，不会换行。 即使所有项目加起来的宽度超过了容器的宽度，也不会换行，并且项目为了挤在一行里，会在宽度上进行压缩。 如果想让项目换行，可以使用flex-wrap属性，定义项目是否换行，以及如何换行。 flex-wrap可以去三个值： flex: none和flex: 1 如果在一行放不下的情况下，我们要求项目即能够排在一行里，宽度又不被压缩，我们就可以用到项目属性，flex，他可以控制项目的放大和缩小。 不允许项目压缩、放大flex： none 默认不设置flex属性 项目设置了flex：none 项目自动充满剩余空间flex： 1 默认情况，不设置flex属性 所有项目都设置了flex： 1 两栏自适应布局 当一个页面中，有两个项目，把其中一个项目设置成固定宽度（flex: none),另一个设成自适应宽度（flex: 1）,完成后，页面就可以随着浏览器宽高的改变而自动改变项目的大小。 flex-direction flex布局默认的排版方向是水平的，如果想要改变其排版方向，可以使用flex-direction去改变其排版方向。 主轴和交叉轴 首先需要了解一下flex布局的两根轴----主轴和交叉轴 默认情况下两根轴的方向： 主轴：水平，从左到右；交叉轴：垂直，从上到下 容器中的项目默认按照主轴方向排列 注意：主轴和交叉轴是相互垂直的关系，交叉轴的方向会随着主轴方向的改变而改变，两轴始终保持垂直关系 改变容器中主轴和交叉轴的方向flex-direction flex-direction有四个有效值： row:默认值，主轴为水平方向，起点在左端。 row-reverse:主轴为水平方向，起点在右端。 column:主轴为垂直方向，起点在上。 column-reverse:主轴为垂直方向，起点在下。 主轴改变后的影响 默认情况下，justify-content和align-items分别控制水平方向和垂直方向上项目的分布。 用flex-direction改变主轴方向后，justify-content和align-items控制的方向也会改变： 默认情况：justify-content控制水平方向，align-items控制垂直方向； 设置了flex-direction: column： justify-content控制垂直方向，align-items控制水平方向； CSS高级美化 单行文本超出省略 在网页中常见到文本内容溢出问题，解决方法是用省略号代替剩余内容。分三步： 强制不换行 使用white-space： nowrap，实现文本不换行。 元素内容溢出 进一步设置，对超出的文本进行处理，将文本超出部分进行隐藏，需要用到overflow： hidden。 overflow有五个有效值： visible: 这是默认值，从父元素继承overflow属性的值。 hidden: 内容会被修剪，并且超出内容不可见。 inherit: 内容不会被修剪，会呈现在元素框之外。 scroll: 内容会被修剪，浏览器会显示滚动条以便查看超出的内容。 auto: 由浏览器定夺，如果内容被修剪，就会显示滚动条。 文本溢出省略 最后用省略号代替剩余内容，css中有专门处理文本溢出的属性：text-overflow text-overflow有两个有效值： clip： 默认值，表示在内容区域的极限处截断文本，可以简单的理解成超出部分被一刀切除掉了。 ellipsis: 表示用一个省略来表示被截断的文本。 总的css即为： 多行文本超出省略 对于多行超出省略，需要WebKit内核的浏览器，具体代码为： 其他浏览器目前没有CSS属性可以直接控制多行文本的省略显示。这个也可以使用js完成。 SCSS介绍（CSS预处理器） 什么是SASS SASS是一款CSS预编译器，它定义了一种新的编程语言，为CSS增加了一些编程的特性，开发者使用这种语言进行编码后，代码需要被编译成CSS才能被浏览器理解。 SASS比CSS更像一门编程语言，他可以有变量，有函数，控制语句，导入，嵌套等高级功能，类似的CSS预编译器还有less、Stylus等。 SASS可以： 提供变量，实现一键替换主题色之类的功能； 用嵌套写法减少选择器的重复书写； 用混用功能解决代码复用问题； 用函数进行复杂的运算； 把样式代码模块化，减少不同模块的代码间不必要的相互影响，提高代码安全性； 写好的Sass/Scss文件会在运行代码之后直接编译成同名的CSS文件，因此在HTML文件中引入编译后的CSS文件即可。 Sass和Scss Scss其实是Sass3为了兼容CSS引入的新语法。 CSS的语法是选择器+声明块，声明块是由花括号和声明组成。但是最早的Sass语法格式，被称为**缩进格式(indented Sass)**通常简称“Sass”，是一种简化格式。它使用&quot;缩进&quot;代替&quot;花括号&quot;表示属性属于某个选择器，用“换行”代替“分号”分隔属性。例如： Sass3引入的新语法，也就是Scss，其语法完全兼容CSS3，并且继承了Sass的强大功能。也就是说，任何标准的CSS3样式表都是具有相同语义的有效Scss文件。 Sass和Scss的大部分扩展，例如变量、parent reference 和 指令都一致的；唯一不同的是，SCSS需要使用分号和花括号而不是换行和缩进。 变量 在CSS属性上Sass提供了一些名为SassScript的新功能。SassScript可作用于任何属性，允许属性使用变量、算术运算等额外功能。 SassScript最普遍的用法就是变量，变量以美元符号“$&quot;开头*，（变量支持简单的加减乘除）赋值方法与CSS属性的写法一样： 如果变量类型为字符串，一般不需要加引号，但是有些特殊情况，比如字符串中包含有双斜杠“//&quot;,就需要用英文输入法状态下的单引号或者双引号包裹字符串，用引号的写法： 插值法 **#{}**插值几乎可以在Sass样式的任何地方使用： .icon-#{name}: &quot;name&quot;为&quot;mail&quot;,编译后选择器为：.icon-mail; url(&quot;.icons/#{$name}.svg&quot;): 编译后图片路径为&quot;/icons/mail.svg&quot;; 可以使用插值法插入任何类型的变量，不仅仅是字符串。 嵌套 Sass允许将一套CSS样式嵌套进另一套样式中，内层的样式将它外层的选择器作为父选择器，例如： 嵌套功能避免了重复输入父选择器，而且令复杂的CSS结构更易于管理。 父选择器&amp; 在嵌套CSS规则时，有时也需要直接使用嵌套外层的父选择器，可以用**&amp;**代表嵌套规则外层的父选择器： 更加特殊的用法： 嵌套功能使样式代码的结构更清晰，大大降低了写错的概率，安全性、可读性、可维护性上都有很大的提升。 复用：mixin/include 很多编程语言中都有解决代码复用的方案，sass也不例外，我们可以用混合（mixin/include)来定义可重复使用的样式。 mixin/include除了可以用来解决代码复用问题，还能解决无语义的类名问题（比如:&quot;.float-left&quot;)。 无参数混合 在css中我们可以通过复用类名，来实现代码的复用，现在，我们使用Sass的mixin/include来解决复用的问题： 被**@mixin标记的代码是可复用代码，使用@include**可以将复用代码获取并使用。 有参数混合 参数无默认值 向square传入一个值，然后根据传入的值对元素进行样式处理。 参数有默认值 有默认值存在时，在未给复用代码传参时就引用默认值去进行样式处理。 响应式布局（CSS响应式） 什么是响应式网页设计 响应式布局这个概念是Ethan Marcotte在2010年5月提出的一个概念，简而言之，就是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。 响应式布局主要通过规定特定的宽度范围使用特定的布局来实现在不同的设备上应用不同的布局。（如：Github在不同客户端打开，页面的布局是有区别的） 响应式不仅仅指页面在不同设备上布局不同，在同一设备上，通过调节浏览器的宽度，布局也会发生变化，这也是响应式布局。 要使页面在不同的宽度范围内使用特定的布局，就需要制定对应的规则，这里需要使用CSS3中的媒体查询@media了 媒体查询 什么是媒体查询 媒体查询是CSS3中引入的一种CSS技术。仅当满足特定条件时，他才使用对应的CSS属性块。 基础语法： &quot;screen&quot;: 告知设备在打印页面时使用衬线字体，在屏幕上显示时用无衬线字体。如果网页不需要考虑用户去打印时，你可以直接这边把上图代码中的“screen and”去掉。 条件：最大宽度（max-width）和最小宽度（min-width） 在上图中and后面跟着的就是查询条件，当满足条件后就会执行样式。 逻辑操作符 and 即同时满足被and所连接的条件后，才执行样式。 断点 所谓断点，就是把屏幕分成多个阶段的点。如，用（900 px和1080 px）把屏幕分成三段，其中900 px和1080 px就是断点。 因为响应式布局是为了页面能够兼容多个终端而提出的，因此断点值的设置和设备的尺寸有 很大关系。 典型的断点有： 冲突的媒体查询条件 当两个媒体查询条件发生冲突时，由于CSS中越靠后的样式优先级越高的原则，会执行后面定义的样式。为了更好的达到预期： 媒体查询用max-width表示条件的时候，大的断点方上面。 用min-width表示条件时，小的断点放上面。 ","link":"https://jiuxiazz.github.io/post/web/"},{"title":"JavaScript","content":"JS 什么是Js ​ JS(JavaScript)，是一种转为与网页交互而设计的脚本语言。主要由三部分组成： 核心（ECMAScript） 文档对象模型（DOM） 浏览器对象模型（BOM） ​ 核心（ECMAScript）：规定了这门语言的基本组成部分，主要是由语言、类型、语句、关键字、保留字、操作符、对象组成。 ​ 文档对象模型（DOM）：DOM的功能就是可以获取我们写的所以html标签，开始标签添加或删除样式，并可以给标签添加事件，这些功能的实现是基于下面三种接口实现： ​ 浏览器对象模型（BOM）：BOM只会处理跟浏览器相关的东西，比如： 弹出新窗口功能 移动、缩放、关闭浏览器窗口的功能 给用户提供显示器分辨率的功能 提供浏览器信息 JS的书写 ​ JS的书写位置一遍有两种： 在body标签内创建一个script标签，在标签内进行js的编写。 创建一个js文件，然后在body标签内创建script标签，通过src进行连接js与html文件，例如：&lt;script src=&quot;***.js&quot;&gt;&lt;/script&gt;. JS的基础用法 注释： 单行注释：//注释内容 多行注释：/* */ 字符串： 由单引号或者双引号引住的都是字符串。 console访问控制台： 使用console.log(内容)可以是内容在控制台（console）中显示,页面右击检查，就可以看见。这里的内容可以是字符串，变量等。 模板字符串： 对于字符串和变量的拼接，可以使用反引号进行包裹，变量用占位符${变量}包裹。如: 变量 ​ JS中定义变量的关键字有两个，let和const，这两个可以用来命名各种类型的数据，如，数字，字符串等等；（var 已经过时，使用时可能会有很多错误） ​ 这两种关键字的异同点： ​ 同：不能定义多个同名的元素。 ​ 异：let可以多次重新赋值，const定义的变量只能赋值一次，let定义变量时，可以不赋初始值，const必须赋初始值，否则会报错。 数据类型 常用的数值为：整数，浮点数和NaN（Not a Number非数值）。 需要注意的是：两个浮点型相加不一定就是正常运算得到的值，例如：0.1+0.2=0.3这是错的，他俩相加为0.3000000004.这是精度丢失现象。出现NaN的情况有： 0/0 字符串乘以数字 NaN和任何数进行运算 类型转换/字符串拼接 这里牵扯到两种类型转换：隐式转换和强制类型转换 隐式转换： 数字字符串加数字，数字隐式转换为字符串 数字字符串与数字做非加法运算，字符串隐式转换为数字 数字字符串与数字字符串做非加法运算，隐式转换为数字 强制转换： parseInt使用于 整数字符转换为整数 小数字符串转换为整数 小数转换为整数 parseFloat使用于 小数字符串转换为小数 字符串拼接 字符串拼接使用的符号是+（加号） 字符串用引号引起来，单引号不做要求，但是要对应，不能是前半部分单引号，后半部分双引号。 变量名不能用引号，如果变量名在字符串中间，可以用加号和引号区分开来。 运算符 相等于全等： 相等（==）：判断两个变量是否值相等但不考虑类型是否相等，如‘20’ == 20 结果为true。 全等（===）：不仅判断两个变量是否值相等还要考虑类型是否相等，上述例子结果为false。 自增自减： 自增（++）：分两种 n++:这种是该行语句完成后n加1。 ++n:这种是n先加1再执行该行语句。 自减（--）：同自增。 除了等于和全等其他的和java都一样，就不赘述了。 布尔类型 布尔类型就是true（真）和false（假），它是区分大小写的true和false是布尔类型的，但TRUE和FALSE不是布尔类型。 转换为true的值： 字符串：任何非空字符串 数字：任何非零数字 转换为false的值： 字符串：&quot; &quot;(空字符串) 数字：0 认识数组 数组的表示方法： [ ] 数组中可以存放任何类型的数据也可以存放数组。 数组的创建：let arr = new Array();(括号里面也可以写数据，用来初始化数组，数据间用,隔开) 数组的索引是从0开始的。 数组的操作： 增： push方法（从尾加）：变量名.push('要加的值'); unshift方法（从头加）：同上。 删： pop方法（从后往前删除）：变量名.pop();一次删除一个数据。 shift方法（从前往后删除）：同上。 splice方法（删除指定位置的值）：括号里面可以有多个参数 一个参数：变量名.splice(1)删除从索引为1处到最后的数据。 两个参数：变量名.splice(1, 2)删除从索引1处开始的两个数据。 改： splice方法：该需要三个参数 变量名.splice(2, 1, &quot;江苏大学&quot;)这个意思就是从索引为2的地方开始往后数1个单位的数据（可以是多个数据）被参数三（江苏大学）替代。如果把参数二改为0，可以做到在索引2后面插入参数三的功能。 查： indexOf()括号里面可以写两个参数： 一个参数：整个数组进行查询看是否有该参数。找到就返回元素下标，未找到返回-1 两个参数：第一个还是要查找的值，第二个为开始查找的位置。 以上方法都只用于一维数组，二维数组使用会有差别，想要使用，则需要把二维数组内的一维数组单另拿出来使用。 二维数组： ​ 二维数组就是一维数组里面放入数组作为数组元素。在二维数组中，如果不在空的一维数组里面添加元素，直接调用会报错，因为空的一维数组获得的数据为undefind，再去执行调取一维数组就是无效操作了，然后就会报错。 函数 函数就是一段可以反复调用的代码块。 自定义函数： 用function命令声明（关键词） 关键词后是函数名，这个可以自己取（要符合规则） 函数名后为小括号（） 再接着就是包裹函数体的大括号{}。 函数表达式： let print = function(){};print就是函数名，大括号内为函数体。 简写形式：let print =（）=&gt;{};这种形式不会对函数进行函数声明的提升。 函数声明的提升：采用function命令声明函数时，整个函数会被提升到代码头部。如： 这种的就不会报错，但是如果用上面的简写形式就会报错。 两种形式的区别： function命令声明结尾的大括号不需要加“；”函数表达式的需要加。 function命令声明的有声明提升，函数表达式的没有。 重复声明的函数： 前者定义的会被后者覆盖。 立即执行函数:（IIFE） (function(){ })();这种函数只会被执行一次，但会立刻执行。 在JS里面函数的参数不需要声明类型。但是当函数有多个参数的时候，在调用函数的时候，参数的个数可以超出也可以缺少，超出部分不会被采用，缺少部分会按默认值带入函数（默认值为undefined)默认值也可以在声明函数的时候自己定义，定义方式为：function demo(num1 , num2 = 1){}这里的num2 = 1就是设置num2的默认值为1. 在JS里面函数的返回值没有类型的规定，任何类型均可返回。 几个适用性函数 延迟执行函数： let timeId = setTimeout(函数名 , delay);timeId是定时器的编好，delay是延迟执行的时间，单位为毫秒。（只能执行一次，要通过循环来实现多次使用). let timeId = setInterval(函数名 ，delay);与上面不同的是他可以无限调用，要加入结束语句才能停止，而且是先进性延迟然后再进行执行函数。 Math函数: Math.E常数e Math.LN22的自然对数 Math.LN1010的自然对数 Math.LOG2E以2为底的e的对数 Math.LOG10E以10为底的e的对数 Math.PI常数π Math.SQRT1_20.5的平方根 Math.SQRT22的平方根 Math.abs()绝对值 Math.ceil()向上取整 Math.floor()向下取整 Math.round()四舍五入取整 Math.max()最大值 Math.min()最小值 Math.pow()指数运算 Math.sqrt()平方根 Math.log()自然对数 Math.exp()e的指数 Math.random()获得一个[0,1)的数字 Storage函数：（Storage接口用于脚本在浏览器保存数据。保存的数据在浏览器：检查=&gt;应用（Application)=&gt;存储,里面查看） window.sessionStorage.setItem('Key',‘value’);保存的数据用于浏览器的一次会话，当会话结束，数据就会被清空。 window.localStorage.setItem('key','value');保存的数据可以长期存在，下次访问该网站的时候，网页可以直接读取以前保存的数据。 把setItem换成getItem,去掉value救赎数据读取方法。 换成clear就是清除数据。还有一点就是这些key和value都是字符串，如果存入的不是字符串会先转换成字符串然后存入。 函数作为参数时，不需要加括号。 对象 对象就是一组“键值对”（key-value),一种无序的复合数据集合。 对象的定义： 大括号：定义一个对象； person:定义的对象被赋给person，则person将指向这个对象； name：‘ali':键值对（key：value），键值之间用：隔开； 一个对象中可以包含多个键值对，每个键值对之间用,隔开，最后一个键值对后可以加,也可以不加。 当一个对象被赋值给person，在person中保存的其实是对象的内存地址，而不是对象本身，这种赋值被称为“引用”，这种定义对象的方法称为“字面量”。 对象的键名基本都是字符串，所以键名加不加引号都是一样的。 在对象中，属性（键名）可以是任何数据类型，包括函数，又称该对象的方法。 对象的创建： 创建一个构造函数，构造函数的名称通常是大驼峰命名法命名； 通过new创建对象实例； 这里的this就是表示将传入的参数name赋值给对象实例中对应的属性。 属性的读取： 对象名+.+要访问的属性； 对象名+['属性名称']； 也可以先将属性名赋给一个变量，然后括号里面用变量名代替。 属性是一个对象：（链式引用） ​ 如果属性是一个对象，那么就要用套娃的形式了，读取就要在后面加上.对象里面的对 象的属性，或者中括号后面再加个中括号。如： 属性的赋值： ​ 读取 = 要赋的值； 属性的查看： ​ 因为Js里面所有的对象都是继承自Object对象，所有这些对象都是Object的实例。 ​ 这里使用Object的一个方法：Object.key(对象名)该方法返回值为一个数组，数组是 由对象里面所有属性名构成的。 属性的删除和增加： ​ 删除：delete+对象.变量名 or delete+对象[变量名]; ​ 增加：对象名.属性名=属性值 or 对象名[属性名] = 属性值； 遍历对象属性： 使用for....in遍历属性，这里的key是键名。 借助Object.keys遍历属性，注意这里返回的是一个由键名构成的数组，遍历时通过调用数组里面的值达到遍历效果。 对象的继承： ​ 简单的来说，就是用一个变量new一个对象，（let o4 = new o1()这里o1是一个对象)这就是继承，o4继承了o1，o1是o4的原型，Object是o1的原型。 属性是否存在： ​ 键名 in 对象名； 自身属性是否存在： ​ 对象名.hasOwnProperty('变量名'); Object与JSON、Map的区别： ​ JSON： JSON是一种轻量级的文本数据交换格式，他用JavaScript的语法书写，但独立于这种语言，可以认为这是编程语言间用于传递数据而约定的数据格式。 JSON.parse(变量)：JSON格式=&gt;JavaScript对象。 JSON.stringify()：JavaScript对象=&gt;JSON格式。 ​ Map： 一个Object的键通常是字符串，但一个Map的键可以是任意值。 Map中的键值是有序的，而添加到对象中的键则不是。 Map的键值对个数可以直接获取，Object则要借助Object.key()等计算得到。 Map可以直接进行迭代，Object则要借助Object.key()等。 Map不存在键名和原型键名冲突问题，可以直接覆盖，Object则不行。 Map不能直接转为JSON格式进行通讯，所以Map一般作为Object的补充使用。 内置对象--String： 包装对象：let str = new String('abc'); 字符串的长度：let len = &quot; adada &quot;.length;这里的长度包括空格。 查找字符：let index = str.indexOf('an');存在就返回下标，不存在就返回-1。 去掉两端空格：let str1 = str.trim();返回的是去掉空格后的字符串。 截取字符串： substring(start,end)：start---要截取的字符串的开始下标，end---要截取的字符串 的结束下标。 ​ substr(start,len)：start---要截取的字符串的开始下标，len---要截取的字符串的长 度。 ​ 上述两个函数，如果第二个参数不写，则会一直截取到字符串结束。 分割字符串：solit('丨');将用丨分割字符串，分割开的内容存入一个数组中，并返回。 内置对象--Array： 连接数组：join('x');和split方法正好相反，join是用x把数组里面的各元素分隔开，然后返回一个字符串。 倒序排列：arr.reverse()颠倒排列数组元素，返回改变后的数组。 排序：arr.sort(function (a,b){ return a.age - b.age;});这里的a.age和b.age 他们的值必须是数字，a-b则正序排列，b-a则倒序排列。 遍历： 有返回值的遍历： map方法的三个参数： elem：表示依次传入的数组成员 index：表示依次传入的数组成员所对应的下标 a：表示整个数组 map的返回值是由return后的内容组成的数组。 无返回值的遍历： arr.forEach()和map用法一样，只是没有返回值。 内置对象--Date： Date对象是以国际标准时间（UTC)1970年1月1日00:00:00作为时间的零点。 let now = new Date();获得当前时间，括号里面也可以传入一些参数，有三种写法： Date(2020,0,6,0,0,0);传入表示年月日时分的数字 Date('2020-1-6');传入日期字符串 Date(157824000000);传入距离国际标准时间的毫秒数 传入的时间会被减去八个小时，原因是打印出来的是UTC的时间，与咱们东八区相差八个小时，其次还有个要注意的点，月份的范围是0-11. 日期的运算： 两个Date对象直接相加就可以得到两者的毫秒数差，比较大小直接使用大小于符号。 解析日期字符串： Date.parse();方法用来解析日期字符串，返回该时间距离时间零点的毫秒数。 时间对象转字符串： toJSON();获得的比当前时间晚八个小时，原因同上； 获取时间对象的年/月/日： 变量.getTime();返回实际距离零时的毫秒数； 变量.getDate();返回实例对象对应每个月的几号，从1开始； 变量.getDay();返回星期几，星期日为0； 变量.getFullYear();返回四位的年份; 变量.getMonth();返回月份，从0开始; 变量.getHours();返回小时，从0开始； 变量.getMilliseconds();返回毫秒。从0开始； 变量.getMinutes();返回分钟； 变量.getSecond();返回秒； 设置时间对象的年/月/日： 和获取一样，只是少了setDay()其他都有，区别在于把get换成set。 BOM BOM是浏览器对象模型的简称，它是由一系列相关对象构成，每个对象都提供很多方法和属性。其中有四个最重要的对象： window(窗口)：window是整个网页的框架，每个网页的内容都是装载在window里面 navigator(浏览器):navigator里面存储浏览器相关信息 history(历史):每个网页可以前进后退，history就是拿来存储整个网页栈的 screen(显示屏幕)：screen包含我们显示屏幕的信息，这个是硬件信息 Location(地址):location包含当前访问的地址（网站）信息 screen是整个电脑唯一的 navigator是整个浏览器唯一的，如果有多个浏览器就会有多个navigator window是每个网页唯一的，每个网页都有一个独立的window history，location是每个网页的信息，当然也是网页唯一的 window window对象表示一个浏览器窗口或一个frame框架，它处于对象层次的最顶端，他提供了处理浏览器的方法和属性。 window对象是浏览器对象的默认对象，所以可以隐式地引用window对象的属性和方法。在浏览器环境中，添加到window对象中的方法、属性等，其作用域都是全局的。 window的方法要去MDN中查询。 Location/History Location有很多属性： href整个网页地址 hostname网页的域名 host网页域名+端口号 protoct协议信息 origin页面来源域名的标准形式 pathnameurl路径部分 searchurl参数 Location方法： reload()刷新网页 跳转到新的地址： window.location = '.....'; History: 每当我们在网页中进行页面跳转时，当前网页以及之前的网页都会被存入栈内，后访问的网页在栈顶。 其中有两个方法很重要： back();返回上一个网页 forward();前往下一个网页 Navigator/Screen Navigator表示用户代理的状态和标识，也就是浏览器的基本信息，其中有个属性很重要---userAgent,代表当前浏览器的用户代理。输出该属性得到的结果如下格式： Mozilla是一个基金会，表示这是一个主流浏览器，Intel mac OS X 表示电脑信息为Mac Chrome/79,0表示浏览器版本。 Screen就是电脑屏幕。 DOM DOM又称文档对象模型，可以将web网页与脚本或编程语言连接起来。 DOM树特征： 树根是DOCUMENT，也可以称为整个网页文档。 每个HTML标签我们称之为DOM节点，英文为Node或者Element。 每个HTML标签的子标签，在树上体现为分支，称为儿子节点。 儿子节点类推可以得知其下的标签是孙子节点。 标签的长辈，我们称为是祖先节点。 同级的标签，我们称为兄弟节点。 Chrome调试工具： 非工程目录区域右击，点击检查开启开发者窗口 开发者窗口里面切换到Console面板 再次点击代码演示 里面可以看到Console里面出现调试里面输出的内容，这是Chrome单独处理过的 获取DOCUMENT： DOCUMENT元素会存在全局变量window下面，平时可以使用window.document.......来访问。 选择器查询： querySelector():单选一个满足条件的节点。（括号里面是要选择的标签名或类名或id名） querySelectorAll():选择所有满足条件的节点，其返回值为数组。 其他筛选方法： getElementById():根据id查询某个节点 getElementsByClassName():根据class查询多个节点 getElementByTagName():根据标签名查询多个节点 上述的两种查询方法，其最主要的区别为--动态性 querySelector查询出来的元素是拷贝的原始数据，不会再随着页面DOM节点的改变而改变get系列方法，查询出来的元素就是原始数据，所以会随着页面的DOM节点的改变而改变。 DOM 属性 DOM类型可以归纳为： 元素节点 特征节点 文本节点 其他节点 其特征为： 整个HTML中，无论是标签，标签属性，还是纯文本字符串都是Element,不同的地方在于nodeType分别为1,2,3. HTML标签都是元素节点，可以用nodeName获取标签名称 纯文本都是文本节点，可以用nodeValue获取文本内容 标签的每一个属性都是特征节点，可以用nodeName获得属性Key，用nodeValue取得属性Value attributes可以获取元素节点的所以属性，得到的结果是一个字典，通过属性Key获取对应的特征节点 无论是标签，标签属性，纯文本，他们都是节点。 DOM内容： 分别是下面三个属性得到： outerHTML:获得整个DOM的HTML代码 innerHTML获取DOM内部HTML代码 innerText获取DOM内部纯文本内容 DOM亲属： firstChild指定节点的第一个节点 lastChild指定节点的最后一个子节点 childNodes指定节点的子节点的集合 parentNode指定节点在DOM树中的父节点（包括自己） DOM样式： classList用classList数组方式存储所以的class名称 style获得对象或字典的方法存储CSS里面的Style DOM数据属性： HTML提供一种数据属性的标准，利用data-*允许我们在标准内于HTML元素中存储额外的信息。 使用dataset可以查询数据属性，它是一个Map对象，它是data-*里面的*的Key-Value集合。 例如： DOM操作 创建标签节点 document.createElement('tagName')：tagName是标签的名称。 document.createTextNode('string'):在标签内添加纯文本内容。 添加新节点 appenChild(newNode):在所以儿子节点之后添加。 inserBefore(newNode, referenceNode)：在referenceNode节点之前添加。 设置样式、属性 setAttribute('style','width: ***; height: ***;');：其中这里的style还可以是id、src、type、disabled等。 dom.style.color = '**'：对单个属性也可以这些写，这里的color也是可以换成别的属性。 dom.style.cssText = 'css'这个也可以用来改变节点属性，但是有限制。 对类的操作 dom.className = '**'这个可以给刚刚创建的节点增加类名。 dom.className.add('*')和dom.className.remove('*')分别是类名的增加和删除。 dom.classList.toggle('**');如果类名已存在，则移除它，否则添加它。 dom.classList.replace('name1','name2'):将name1替换成name2. 清除标签内容 dom.innerHTML = ''：它的作用就是将dom的内容清除掉 控制元件的显示与消失 display = 'none'和display = 'block'：这里通过改变节点的类型来实现显示和消失。 DOM事件 给一个元素添加一个事件： dom.addEventListener(&quot;事件名称&quot;, function(){事件触发的效果})这是在Js里面给元素添加事件； &lt;div onclick=&quot;console.log('xxx')&quot;&gt;&lt;/div&gt;:这是在HTML里面给添加事件，但一般不使用，因为当项目大之后，这样会使HTML变得很大。 替代上述的JS代码： dom.onclick = function(){} 最实用的还是第一种方法。 事件的属性及作用： target:使事件触发的DOM节点。（包含标签如：123） type:触发的事件的名称，即第一种方法中的事件名称。 pageX/pageY：鼠标事件触发的页面的坐标。 事件有很多，这里只列举几个常用的： 焦点事件： focus:表单组件获取焦点事件 blur：表单组件失去焦点事件 鼠标事件： click:点击事件 dblclick:双击事件 mousedown:在元素上按下任意鼠标按钮 mouseenter:指针移到有事件监听的元素内 mouseleave:指针移出元素范围外（不冒泡） mousemove:指针在元素内移动时持续触发 mouseover:指针移出元素，或者移到它的子元素上 mouseup:在元素上释放任意鼠标按键 键盘事件： keydown:键盘按下事件 keyup：键盘释放事件 视图事件： scroll：文档滚动事件 resize：窗口放缩事件 资源： load：资源加载成功的事件 冒泡、捕获、委托 对于被触发事件的dom事件，触发元素被叫做事件源，dom标准事件流的触发先后顺序为：先捕获再冒泡。即当触发dom事件时，会先进行事件捕获，捕获到事件源之后通过事件传播进行事件冒泡。 事件冒泡： 一个元素加入事件后，触发事件后会向它的父元素继续冒泡找添加事件的元素，如果找到就会触发被找到元素的事件。 ​ 阻止冒泡的方法是：e.stopPropagation() ​ 该语句使用地方为：放在事件函数里面，意思就是禁止该事件向上冒泡（不触发父元素的事件）。 事件捕获： 捕获和冒泡事件是相反的，对于捕获来说是从根HTML节点开始依次移动到当前元素。 ​ 如果对于一个事件想要在捕获阶段被监听则需要在元素添加事件的时候加入一个参数即：dom.addEventListener(' ', function(){} , true)这里的true就是让事件被捕获阶段得到监听。 事件委托： 委托是冒泡事件的一种应用，当多个同级元素要完成同一个或近乎相同的事件时，不对子节点设置监听器，而是将监听器设置在父节点上，然后通过冒泡，冒泡到父节点上。在委托中，事件的target表示的是真是响应事件的DOM节点，因为父元素的范围比子元素的大，所以在使用的时候我们要判断一下响应事件的元素（通过判断e.target.nodeName是不是目标元素的元素标签） 移动事件 mouseenter：指针移到有事件监听的元素内。 mouseleave:指针移出元素范围外（不冒泡）。 mousemove：指针在元素内移动时持续触发。 mouseover:指针移到有事件监听的元素或者它的子元素内。 mouseout:指针移出元素，或者移到它的子元素上。 总结： 1.mousemove 这个是鼠标移动事件，比较简单 2.mouseenter/mouseleave 这个是鼠标进入和离开事件，但是仅仅只作用于当前DOM节点，不会作用于其后代节点。 3.mouseover/mouseout 这个也是鼠标进入和离开事件，但和enter/leave不同的是：此事件除了作用于当前DOM节点，也会同时作用于其后代节点 表单元素事件 焦点事件： 获取焦点和失去焦点------focus和blur 内容值变化 监听元素内容变化------input和change，其中input是在输入值时就会触发，change需要在输入框失去焦点后才会触发。 滚动事件 scroll 其中scrollY是获得Y轴滚动距离 内容高度:document.body.clientHeight 浏览器高度:window.screen.height 滚动距离:window.scrollY 滚动距离底部距离：内容高度-浏览器高度-滚动距离 ","link":"https://jiuxiazz.github.io/post/javascript/"},{"title":"Vue","content":"Vue配置 Vue是用于构建用户界面的渐进式框架. 安装 node.js 下载完node.js会附带有npm(包管理工具),下载完后使用node -v来检测是否安装成功.使用npm -v检测npm是否下载成功. 安装Vue CLI(脚手架) Vue CLI简单来说就是Vue工程的升级版.安装脚手架的方法很简单,执行npm install -g @vue/cli(mac电脑需要在命令前面加个sudo) 如果长时间安装不好,可以使用淘宝镜像安装,依次执行 sudo npm install -g cnpm --registry=https://registry.npm.taobao.org切换镜像 cnpm install -g @vue/cli 安装完成后验证vue --version 创建Vue工程 执行完上述所有操作后,会获得一个以vue开头的命令. vue create vue_name cd vue_name npm run serve Vue工程目录介绍 下图为Vue建好后初始的工程结构: assets: 存放项目中需要用到的资源文件,css,js,images等. componets: 存放vue开发中一些公共组件:例如项目初始的header.vue、footer.vue就是公共组件。 router: vue路由的配置文件。 views: 存放页面文件。 app.vue: 根组件 main.js: 项目的入口文件，定义了vue实例，并引入根组件app.vue,将其挂载到index.html中id为'app'的节点上。 Vue双向绑定 声明式渲染 每个Vue文件都是由三部分组成, template、script、style,他们分别对应HTML、JavaScript、CSS. 需要注意的是，在template里面只允许有一个块状元素，多了就会报错。 差值表达式渲染 使用差值表达式的方式为： 在script中声明字符串变量： 使用该变量： 这里的双大括号就会使其在渲染的时候渲染为 asd 3. 样式添加： 这里展示的是字符串的使用，如果是数组，双大括号里面使用变量名[]就好，中括号里面是index 处理用户输入 v-model(双向绑定)--input： 双向绑定就是当我们在下面input框内输入内容时，上面的框里内容也会改变。 使用： 这里的message需要事先定义好。 复选框也可以用这个实现将选定好的内容展示出来： 这里只需要将多个复选框（即多个input）都使用v-model绑定到同一个数组即可 处理用户事件 v-on:(事件绑定) 使用： 先进行事件绑定： 这里@是v-on的简写模式，不代表都是@ methods(方法) 2. 给点击事件添加方法 方法中如果用到data中定义的变量，需要在变量前面加个this. 否则会报错，这里的this是指向当前的Vue实例 事件修饰符： 阻止冒泡事件 捕获事件 阻止默认事件 监听数据变化 watch（侦听器）： 使用： 这里就是监听count这个变量，当其发生变化时，就会触发count()这个方法。 进阶使用： handler方法和 immediate属性： 如果想让界面第一次渲染的时候就去触发侦听器，这个时候就需要用到immediate属性，实际上侦听器就是一个对象，里面包含了一个handler方法和其他属性： 当immediate属性为true时，无论数据是否变化，页面刷新以后，handler方法就会运行。 ","link":"https://jiuxiazz.github.io/post/vue/"},{"title":"Android","content":"布局 约束布局 ConstraintLayout 约束布局需要每个控件至少有两个约束条件: 一个水平约束条件和一个垂直约束条件 必须,没有约束条件不会报错但是会打乱控件位置,如水平方向未约束则会将控件位移至视图最左端. 添加约束条件: 在XML文件中,**使用app:layout_constaintTop_toBottomOf=....**来约束该控件的顶部与其他控件底部的关系(类似的只需要更改上面的语句中的Top和Bottom来约束其他方向,可选词:Top Bottom Start End,对应的分别是:上 下 左 右) 在Design界面,选定一个控件,然后控件四周的蓝色圆点击可以拖拽到想要的约束的边界即可 在Design界面,选定一个控件后,在Attributes中点击Constaint Widget中的蓝色加号即可给该方向添加约束条件 删除约束条件: 在XML文件中,直接删除约束语句 在Design界面中,按住Control键,用鼠标点击要删除的约束的线即可 在Design界面中,选中要删除约束条件的控件,在Attributes中点击Constaint Widget中要删除方向的灰色实现圆即可 调整视图尺寸: Fixed: 自定义各个方向的约束距离. Wrap Content: 视图仅在需要时扩展以适应其内容. Match Constraints: 视图会尽可能扩展,以满足每侧的约束条件,可以通过一下属性和值修改行为(这些属性仅在视图宽度设置为match constraints时生效): layout_constraintWidth_default: spread: 尽可能扩张视图以满足每侧的约束条件.(默认) wrap: 仅在需要扩张视图以适应其内容,但如有约束条件限制,视图仍然可以小于其内容。因此，他与使用Wrap Content之间的区别在于，将宽度设为Wrap Content会强行使宽度始终与内容宽度完全匹配；而使用wrap时，视图可以小于内容宽度。 layout_constraintWidth_min: 该视图的最小宽度采用dp维度。 layout_constraintWidth_max: 该视图的最大宽度采用dp维度。 ","link":"https://jiuxiazz.github.io/post/android/"}]}